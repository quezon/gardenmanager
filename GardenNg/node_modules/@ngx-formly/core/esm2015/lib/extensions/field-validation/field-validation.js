/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Validators } from '@angular/forms';
import { isObject, FORMLY_VALIDATORS, defineHiddenProp, isPromise, wrapProperty } from '../../utils';
/**
 * \@experimental
 */
export class FieldValidationExtension {
    /**
     * @param {?} formlyConfig
     */
    constructor(formlyConfig) {
        this.formlyConfig = formlyConfig;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    onPopulate(field) {
        if (!field.parent || !field.key) {
            return;
        }
        this.initFieldValidation(field, 'validators');
        this.initFieldValidation(field, 'asyncValidators');
    }
    /**
     * @private
     * @param {?} field
     * @param {?} type
     * @return {?}
     */
    initFieldValidation(field, type) {
        /** @type {?} */
        const validators = type === 'validators' ? [this.getPredefinedFieldValidation(field)] : [];
        if (field[type]) {
            for (const validatorName in field[type]) {
                if (validatorName === 'validation' && !Array.isArray(field[type].validation)) {
                    field[type].validation = [field[type].validation];
                    console.warn(`NgxFormly(${field.key}): passing a non array value to the 'validation' is deprecated, pass an array instead`);
                }
                validatorName === 'validation'
                    ? validators.push(...field[type].validation.map((/**
                     * @param {?} v
                     * @return {?}
                     */
                    v => this.wrapNgValidatorFn(field, v))))
                    : validators.push(this.wrapNgValidatorFn(field, field[type][validatorName], validatorName));
            }
        }
        defineHiddenProp(field, '_' + type, type === 'validators' ? Validators.compose(validators) : Validators.composeAsync((/** @type {?} */ (validators))));
    }
    /**
     * @private
     * @param {?} field
     * @return {?}
     */
    getPredefinedFieldValidation(field) {
        /** @type {?} */
        let VALIDATORS = [];
        FORMLY_VALIDATORS.forEach((/**
         * @param {?} opt
         * @return {?}
         */
        opt => wrapProperty(field.templateOptions, opt, (/**
         * @param {?} __0
         * @return {?}
         */
        ({ currentValue, firstChange }) => {
            VALIDATORS = VALIDATORS.filter((/**
             * @param {?} o
             * @return {?}
             */
            o => o !== opt));
            if (currentValue != null && currentValue !== false) {
                VALIDATORS.push(opt);
            }
            if (!firstChange && field.formControl) {
                field.formControl.updateValueAndValidity({ emitEvent: false });
            }
        }))));
        return (/**
         * @param {?} control
         * @return {?}
         */
        (control) => {
            if (VALIDATORS.length === 0) {
                return null;
            }
            return Validators.compose(VALIDATORS.map((/**
             * @param {?} opt
             * @return {?}
             */
            opt => (/**
             * @return {?}
             */
            () => {
                /** @type {?} */
                const value = field.templateOptions[opt];
                switch (opt) {
                    case 'required':
                        return Validators.required(control);
                    case 'pattern':
                        return Validators.pattern(value)(control);
                    case 'minLength':
                        return Validators.minLength(value)(control);
                    case 'maxLength':
                        return Validators.maxLength(value)(control);
                    case 'min':
                        return Validators.min(value)(control);
                    case 'max':
                        return Validators.max(value)(control);
                }
            }))))(control);
        });
    }
    /**
     * @private
     * @param {?} field
     * @param {?} validator
     * @param {?=} validatorName
     * @return {?}
     */
    wrapNgValidatorFn(field, validator, validatorName) {
        return (/**
         * @param {?} control
         * @return {?}
         */
        (control) => {
            /** @type {?} */
            let validatorFn = (/** @type {?} */ (validator));
            if (typeof validator === 'string') {
                validatorFn = this.formlyConfig.getValidator(validator).validation;
            }
            if (isObject(validator)) {
                validatorFn = ((/** @type {?} */ (validator))).expression;
            }
            /** @type {?} */
            const isValid = validatorFn(control, field);
            if (validatorName) {
                if (isPromise(isValid)) {
                    return isValid.then((/**
                     * @param {?} result
                     * @return {?}
                     */
                    (result) => {
                        // workaround for https://github.com/angular/angular/issues/13200
                        if (field.options && field.options._markForCheck) {
                            field.options._markForCheck(field);
                        }
                        return this.handleResult(field, result, { validatorName, validator });
                    }));
                }
                return this.handleResult(field, isValid, { validatorName, validator });
            }
            return isValid;
        });
    }
    /**
     * @private
     * @param {?} field
     * @param {?} isValid
     * @param {?} __2
     * @return {?}
     */
    handleResult(field, isValid, { validatorName, validator }) {
        if (isObject(validator) && field.formControl && validator.errorPath) {
            /** @type {?} */
            const control = field.formControl.get(validator.errorPath);
            if (control) {
                /** @type {?} */
                const controlErrors = (control.errors || {});
                if (!isValid) {
                    control.setErrors(Object.assign({}, controlErrors, { [validatorName]: { message: validator.message } }));
                }
                else {
                    delete controlErrors[validatorName];
                    control.setErrors(Object.keys(controlErrors).length === 0 ? null : controlErrors);
                }
            }
            return isValid ? null : { [validatorName]: { errorPath: validator.errorPath } };
        }
        return isValid ? null : { [validatorName]: true };
    }
}
if (false) {
    /**
     * @type {?}
     * @private
     */
    FieldValidationExtension.prototype.formlyConfig;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmllbGQtdmFsaWRhdGlvbi5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BuZ3gtZm9ybWx5L2NvcmUvIiwic291cmNlcyI6WyJsaWIvZXh0ZW5zaW9ucy9maWVsZC12YWxpZGF0aW9uL2ZpZWxkLXZhbGlkYXRpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUVBLE9BQU8sRUFBbUIsVUFBVSxFQUFlLE1BQU0sZ0JBQWdCLENBQUM7QUFDMUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxpQkFBaUIsRUFBRSxnQkFBZ0IsRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLE1BQU0sYUFBYSxDQUFDOzs7O0FBR3JHLE1BQU0sT0FBTyx3QkFBd0I7Ozs7SUFDbkMsWUFBb0IsWUFBMEI7UUFBMUIsaUJBQVksR0FBWixZQUFZLENBQWM7SUFBRyxDQUFDOzs7OztJQUVsRCxVQUFVLENBQUMsS0FBNkI7UUFDdEMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFO1lBQy9CLE9BQU87U0FDUjtRQUVELElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxLQUFLLEVBQUUsWUFBWSxDQUFDLENBQUM7UUFDOUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLEtBQUssRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO0lBQ3JELENBQUM7Ozs7Ozs7SUFFTyxtQkFBbUIsQ0FBQyxLQUE2QixFQUFFLElBQXNDOztjQUN6RixVQUFVLEdBQWtCLElBQUksS0FBSyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLDRCQUE0QixDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7UUFDekcsSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDZixLQUFLLE1BQU0sYUFBYSxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFDdkMsSUFBSSxhQUFhLEtBQUssWUFBWSxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxL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QUUsRUFBRSxDQUFDO1NBQ2pGO1FBRUQsT0FBTyxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDO0lBQ3BELENBQUM7Q0FDRjs7Ozs7O0lBdkhhLGdEQUFrQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEZvcm1seUV4dGVuc2lvbiwgRmllbGRWYWxpZGF0b3JGbiwgRm9ybWx5Q29uZmlnIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvZm9ybWx5LmNvbmZpZyc7XG5pbXBvcnQgeyBGb3JtbHlGaWVsZENvbmZpZ0NhY2hlIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9mb3JtbHkuZmllbGQuY29uZmlnJztcbmltcG9ydCB7IEFic3RyYWN0Q29udHJvbCwgVmFsaWRhdG9ycywgVmFsaWRhdG9yRm4gfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBpc09iamVjdCwgRk9STUxZX1ZBTElEQVRPUlMsIGRlZmluZUhpZGRlblByb3AsIGlzUHJvbWlzZSwgd3JhcFByb3BlcnR5IH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuXG4vKiogQGV4cGVyaW1lbnRhbCAqL1xuZXhwb3J0IGNsYXNzIEZpZWxkVmFsaWRhdGlvbkV4dGVuc2lvbiBpbXBsZW1lbnRzIEZvcm1seUV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZm9ybWx5Q29uZmlnOiBGb3JtbHlDb25maWcpIHt9XG5cbiAgb25Qb3B1bGF0ZShmaWVsZDogRm9ybWx5RmllbGRDb25maWdDYWNoZSkge1xuICAgIGlmICghZmllbGQucGFyZW50IHx8ICFmaWVsZC5rZXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmluaXRGaWVsZFZhbGlkYXRpb24oZmllbGQsICd2YWxpZGF0b3JzJyk7XG4gICAgdGhpcy5pbml0RmllbGRWYWxpZGF0aW9uKGZpZWxkLCAnYXN5bmNWYWxpZGF0b3JzJyk7XG4gIH1cblxuICBwcml2YXRlIGluaXRGaWVsZFZhbGlkYXRpb24oZmllbGQ6IEZvcm1seUZpZWxkQ29uZmlnQ2FjaGUsIHR5cGU6ICd2YWxpZGF0b3JzJyB8ICdhc3luY1ZhbGlkYXRvcnMnKSB7XG4gICAgY29uc3QgdmFsaWRhdG9yczogVmFsaWRhdG9yRm5bXSA9IHR5cGUgPT09ICd2YWxpZGF0b3JzJyA/IFt0aGlzLmdldFByZWRlZmluZWRGaWVsZFZhbGlkYXRpb24oZmllbGQpXSA6IFtdO1xuICAgIGlmIChmaWVsZFt0eXBlXSkge1xuICAgICAgZm9yIChjb25zdCB2YWxpZGF0b3JOYW1lIGluIGZpZWxkW3R5cGVdKSB7XG4gICAgICAgIGlmICh2YWxpZGF0b3JOYW1lID09PSAndmFsaWRhdGlvbicgJiYgIUFycmF5LmlzQXJyYXkoZmllbGRbdHlwZV0udmFsaWRhdGlvbikpIHtcbiAgICAgICAgICBmaWVsZFt0eXBlXS52YWxpZGF0aW9uID0gW2ZpZWxkW3R5cGVdLnZhbGlkYXRpb25dO1xuICAgICAgICAgIGNvbnNvbGUud2FybihgTmd4Rm9ybWx5KCR7ZmllbGQua2V5fSk6IHBhc3NpbmcgYSBub24gYXJyYXkgdmFsdWUgdG8gdGhlICd2YWxpZGF0aW9uJyBpcyBkZXByZWNhdGVkLCBwYXNzIGFuIGFycmF5IGluc3RlYWRgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbGlkYXRvck5hbWUgPT09ICd2YWxpZGF0aW9uJ1xuICAgICAgICAgID8gdmFsaWRhdG9ycy5wdXNoKC4uLmZpZWxkW3R5cGVdLnZhbGlkYXRpb24ubWFwKHYgPT4gdGhpcy53cmFwTmdWYWxpZGF0b3JGbihmaWVsZCwgdikpKVxuICAgICAgICAgIDogdmFsaWRhdG9ycy5wdXNoKHRoaXMud3JhcE5nVmFsaWRhdG9yRm4oZmllbGQsIGZpZWxkW3R5cGVdW3ZhbGlkYXRvck5hbWVdLCB2YWxpZGF0b3JOYW1lKSlcbiAgICAgICAgO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRlZmluZUhpZGRlblByb3AoXG4gICAgICBmaWVsZCxcbiAgICAgICdfJyArIHR5cGUsXG4gICAgICB0eXBlID09PSAndmFsaWRhdG9ycycgPyBWYWxpZGF0b3JzLmNvbXBvc2UodmFsaWRhdG9ycykgOiBWYWxpZGF0b3JzLmNvbXBvc2VBc3luYyh2YWxpZGF0b3JzIGFzIGFueSksXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0UHJlZGVmaW5lZEZpZWxkVmFsaWRhdGlvbihmaWVsZDogRm9ybWx5RmllbGRDb25maWdDYWNoZSk6IFZhbGlkYXRvckZuIHtcbiAgICBsZXQgVkFMSURBVE9SUyA9IFtdO1xuICAgIEZPUk1MWV9WQUxJREFUT1JTLmZvckVhY2gob3B0ID0+IHdyYXBQcm9wZXJ0eShmaWVsZC50ZW1wbGF0ZU9wdGlvbnMsIG9wdCwgKHsgY3VycmVudFZhbHVlLCBmaXJzdENoYW5nZSB9KSA9PiB7XG4gICAgICBWQUxJREFUT1JTID0gVkFMSURBVE9SUy5maWx0ZXIobyA9PiBvICE9PSBvcHQpO1xuICAgICAgaWYgKGN1cnJlbnRWYWx1ZSAhPSBudWxsICYmIGN1cnJlbnRWYWx1ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgVkFMSURBVE9SUy5wdXNoKG9wdCk7XG4gICAgICB9XG4gICAgICBpZiAoIWZpcnN0Q2hhbmdlICYmIGZpZWxkLmZvcm1Db250cm9sKSB7XG4gICAgICAgIGZpZWxkLmZvcm1Db250cm9sLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIHJldHVybiAoY29udHJvbDogQWJzdHJhY3RDb250cm9sKSA9PiB7XG4gICAgICBpZiAoVkFMSURBVE9SUy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBWYWxpZGF0b3JzLmNvbXBvc2UoVkFMSURBVE9SUy5tYXAob3B0ID0+ICgpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBmaWVsZC50ZW1wbGF0ZU9wdGlvbnNbb3B0XTtcbiAgICAgICAgc3dpdGNoIChvcHQpIHtcbiAgICAgICAgICBjYXNlICdyZXF1aXJlZCc6XG4gICAgICAgICAgICByZXR1cm4gVmFsaWRhdG9ycy5yZXF1aXJlZChjb250cm9sKTtcbiAgICAgICAgICBjYXNlICdwYXR0ZXJuJzpcbiAgICAgICAgICAgIHJldHVybiBWYWxpZGF0b3JzLnBhdHRlcm4odmFsdWUpKGNvbnRyb2wpO1xuICAgICAgICAgIGNhc2UgJ21pbkxlbmd0aCc6XG4gICAgICAgICAgICByZXR1cm4gVmFsaWRhdG9ycy5taW5MZW5ndGgodmFsdWUpKGNvbnRyb2wpO1xuICAgICAgICAgIGNhc2UgJ21heExlbmd0aCc6XG4gICAgICAgICAgICByZXR1cm4gVmFsaWRhdG9ycy5tYXhMZW5ndGgodmFsdWUpKGNvbnRyb2wpO1xuICAgICAgICAgIGNhc2UgJ21pbic6XG4gICAgICAgICAgICByZXR1cm4gVmFsaWRhdG9ycy5taW4odmFsdWUpKGNvbnRyb2wpO1xuICAgICAgICAgIGNhc2UgJ21heCc6XG4gICAgICAgICAgICByZXR1cm4gVmFsaWRhdG9ycy5tYXgodmFsdWUpKGNvbnRyb2wpO1xuICAgICAgICB9XG4gICAgICB9KSkoY29udHJvbCk7XG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgd3JhcE5nVmFsaWRhdG9yRm4oZmllbGQ6IEZvcm1seUZpZWxkQ29uZmlnQ2FjaGUsIHZhbGlkYXRvcjogc3RyaW5nIHwgRmllbGRWYWxpZGF0b3JGbiwgdmFsaWRhdG9yTmFtZT86IHN0cmluZykge1xuICAgIHJldHVybiAoY29udHJvbDogQWJzdHJhY3RDb250cm9sKSA9PiB7XG4gICAgICBsZXQgdmFsaWRhdG9yRm4gPSB2YWxpZGF0b3IgYXMgRmllbGRWYWxpZGF0b3JGbjtcbiAgICAgIGlmICh0eXBlb2YgdmFsaWRhdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YWxpZGF0b3JGbiA9IHRoaXMuZm9ybWx5Q29uZmlnLmdldFZhbGlkYXRvcih2YWxpZGF0b3IpLnZhbGlkYXRpb247XG4gICAgICB9XG4gICAgICBpZiAoaXNPYmplY3QodmFsaWRhdG9yKSkge1xuICAgICAgICB2YWxpZGF0b3JGbiA9ICh2YWxpZGF0b3IgYXMgYW55KS5leHByZXNzaW9uO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpc1ZhbGlkID0gdmFsaWRhdG9yRm4oY29udHJvbCwgZmllbGQpO1xuICAgICAgaWYgKHZhbGlkYXRvck5hbWUpIHtcbiAgICAgICAgaWYgKGlzUHJvbWlzZShpc1ZhbGlkKSkge1xuICAgICAgICAgIHJldHVybiBpc1ZhbGlkLnRoZW4oKHJlc3VsdDogYm9vbGVhbikgPT4ge1xuICAgICAgICAgICAgLy8gd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMTMyMDBcbiAgICAgICAgICAgIGlmIChmaWVsZC5vcHRpb25zICYmIGZpZWxkLm9wdGlvbnMuX21hcmtGb3JDaGVjaykge1xuICAgICAgICAgICAgICBmaWVsZC5vcHRpb25zLl9tYXJrRm9yQ2hlY2soZmllbGQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXN1bHQoZmllbGQsIHJlc3VsdCwgeyB2YWxpZGF0b3JOYW1lLCB2YWxpZGF0b3IgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXN1bHQoZmllbGQsIGlzVmFsaWQsIHsgdmFsaWRhdG9yTmFtZSwgdmFsaWRhdG9yIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXNWYWxpZDtcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVSZXN1bHQoZmllbGQ6IEZvcm1seUZpZWxkQ29uZmlnQ2FjaGUsIGlzVmFsaWQsIHsgdmFsaWRhdG9yTmFtZSwgdmFsaWRhdG9yIH0pIHtcbiAgICBpZiAoaXNPYmplY3QodmFsaWRhdG9yKSAmJiBmaWVsZC5mb3JtQ29udHJvbCAmJiB2YWxpZGF0b3IuZXJyb3JQYXRoKSB7XG4gICAgICBjb25zdCBjb250cm9sID0gZmllbGQuZm9ybUNvbnRyb2wuZ2V0KHZhbGlkYXRvci5lcnJvclBhdGgpO1xuICAgICAgaWYgKGNvbnRyb2wpIHtcbiAgICAgICAgY29uc3QgY29udHJvbEVycm9ycyA9IChjb250cm9sLmVycm9ycyB8fCB7fSk7XG4gICAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICAgIGNvbnRyb2wuc2V0RXJyb3JzKHsgLi4uY29udHJvbEVycm9ycywgW3ZhbGlkYXRvck5hbWVdOiB7IG1lc3NhZ2U6IHZhbGlkYXRvci5tZXNzYWdlIH0gfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGNvbnRyb2xFcnJvcnNbdmFsaWRhdG9yTmFtZV07XG4gICAgICAgICAgY29udHJvbC5zZXRFcnJvcnMoT2JqZWN0LmtleXMoY29udHJvbEVycm9ycykubGVuZ3RoID09PSAwID8gbnVsbCA6IGNvbnRyb2xFcnJvcnMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpc1ZhbGlkID8gbnVsbCA6IHsgW3ZhbGlkYXRvck5hbWVdOiB7IGVycm9yUGF0aDogdmFsaWRhdG9yLmVycm9yUGF0aCB9IH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzVmFsaWQgPyBudWxsIDogeyBbdmFsaWRhdG9yTmFtZV06IHRydWUgfTtcbiAgfVxufVxuIl19