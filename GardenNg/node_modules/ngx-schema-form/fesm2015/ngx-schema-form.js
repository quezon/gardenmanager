import { distinctUntilChanged, map } from 'rxjs/operators';
import * as ZSchema from 'z-schema';
import { Jexl } from 'jexl';
import { NG_VALUE_ACCESSOR, FormControl, NgControl, FormsModule, ReactiveFormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';
import { ComponentFactoryResolver, Injectable, ChangeDetectorRef, Component, EventEmitter, Input, Output, ElementRef, Renderer2, ViewChild, ViewContainerRef, Directive, NgModule, forwardRef, ContentChildren, SimpleChange } from '@angular/core';
import { BehaviorSubject, combineLatest, Subject, merge } from 'rxjs';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ActionRegistry {
    constructor() {
        this.actions = {};
    }
    /**
     * @return {?}
     */
    clear() {
        this.actions = {};
    }
    /**
     * @param {?} actionId
     * @param {?} action
     * @return {?}
     */
    register(actionId, action) {
        this.actions[actionId] = action;
    }
    /**
     * @param {?} actionId
     * @return {?}
     */
    get(actionId) {
        return this.actions[actionId];
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class FormProperty {
    /**
     * @param {?} schemaValidatorFactory
     * @param {?} validatorRegistry
     * @param {?} expressionCompilerFactory
     * @param {?} schema
     * @param {?} parent
     * @param {?} path
     */
    constructor(schemaValidatorFactory, validatorRegistry, expressionCompilerFactory, schema, parent, path) {
        this.validatorRegistry = validatorRegistry;
        this.schema = schema;
        this._value = null;
        this._errors = null;
        this._valueChanges = new BehaviorSubject(null);
        this._errorsChanges = new BehaviorSubject(null);
        this._visible = true;
        this._visibilityChanges = new BehaviorSubject(true);
        this.schemaValidator = schemaValidatorFactory.createValidatorFn(this.schema);
        this.expressionCompilerVisibiltyIf = expressionCompilerFactory.createExpressionCompilerVisibilityIf();
        this._parent = parent;
        if (parent) {
            this._root = parent.root;
        }
        else if (this instanceof PropertyGroup) {
            this._root = (/** @type {?} */ ((/** @type {?} */ (this))));
            this._rootName = this.createRootName();
        }
        this._path = path;
    }
    /**
     * Provides the unique path of this form element.<br/>
     * E.g.:
     * <code>/garage/cars</code>,<br/>
     * <code>/shop/book/0/page/1/</code>
     * @return {?}
     */
    get _canonicalPath() { return this.__canonicalPath; }
    /**
     * @param {?} canonicalPath
     * @return {?}
     */
    set _canonicalPath(canonicalPath) {
        this.__canonicalPath = canonicalPath;
        this.__canonicalPathNotation = (this.__canonicalPath || '')
            .replace(new RegExp('^/', 'ig'), '')
            .replace(new RegExp('/$', 'ig'), '')
            .replace(new RegExp('/', 'ig'), '.');
    }
    /**
     * Uses the unique path provided by the property <code>_canonicalPath</code><br/>
     * but converts it to a HTML Element Attribute ID compliant format.<br/>
     * E.g.:
     * <code>garage.cars</code>,<br/>
     * <code>shop.book.0.page.1.</code>
     * @return {?}
     */
    get canonicalPathNotation() { return this.__canonicalPathNotation; }
    /**
     * Provides the HTML Element Attribute ID/NAME compliant representation
     * of the root element.<br/>
     * Represents the HTML FORM NAME.<br/>
     * Only the root <code>FormProperty</code> will provide a value here.
     * @return {?}
     */
    get rootName() { return this._rootName; }
    /**
     * Creates the HTML ID and NAME attribute compliant string.
     * @private
     * @return {?}
     */
    createRootName() {
        if (this.schema && this.schema['name']) {
            return this._rootName = this.schema['name'].replace(new RegExp('[\\s]+', 'ig'), '_');
        }
        return '';
    }
    /**
     * @return {?}
     */
    get valueChanges() {
        return this._valueChanges;
    }
    /**
     * @return {?}
     */
    get errorsChanges() {
        return this._errorsChanges;
    }
    /**
     * @return {?}
     */
    get type() {
        return this.schema.type;
    }
    /**
     * @return {?}
     */
    get parent() {
        return this._parent;
    }
    /**
     * @return {?}
     */
    get root() {
        return this._root || (/** @type {?} */ ((/** @type {?} */ (this))));
    }
    /**
     * @return {?}
     */
    get path() {
        return this._path;
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * @return {?}
     */
    get visible() {
        return this._visible;
    }
    /**
     * @return {?}
     */
    get valid() {
        return this._errors === null;
    }
    /**
     * @param {?=} onlySelf
     * @param {?=} emitEvent
     * @return {?}
     */
    updateValueAndValidity(onlySelf = false, emitEvent = true) {
        this._updateValue();
        if (emitEvent) {
            this.valueChanges.next(this.value);
        }
        this._runValidation();
        if (this.parent && !onlySelf) {
            this.parent.updateValueAndValidity(onlySelf, emitEvent);
        }
    }
    /**
     * \@internal
     * @return {?}
     */
    _runValidation() {
        /** @type {?} */
        let errors = this.schemaValidator(this._value) || [];
        /** @type {?} */
        let customValidator = this.validatorRegistry.get(this.path);
        if (customValidator) {
            /** @type {?} */
            let customErrors = customValidator(this.value, this, this.findRoot());
            errors = this.mergeErrors(errors, customErrors);
        }
        if (errors.length === 0) {
            errors = null;
        }
        this._errors = errors;
        this.setErrors(this._errors);
    }
    /**
     * @private
     * @param {?} errors
     * @param {?} newErrors
     * @return {?}
     */
    mergeErrors(errors, newErrors) {
        if (newErrors) {
            if (Array.isArray(newErrors)) {
                errors = errors.concat(...newErrors);
            }
            else {
                errors.push(newErrors);
            }
        }
        return errors;
    }
    /**
     * @private
     * @param {?} errors
     * @return {?}
     */
    setErrors(errors) {
        this._errors = errors;
        this._errorsChanges.next(errors);
    }
    /**
     * @param {?} errors
     * @return {?}
     */
    extendErrors(errors) {
        errors = this.mergeErrors(this._errors || [], errors);
        this.setErrors(errors);
    }
    /**
     * @param {?} path
     * @return {?}
     */
    searchProperty(path) {
        /** @type {?} */
        let prop = this;
        /** @type {?} */
        let base = null;
        /** @type {?} */
        let result = null;
        if (path[0] === '/') {
            base = this.findRoot();
            result = base.getProperty(path.substr(1));
        }
        else {
            while (result === null && prop.parent !== null) {
                prop = base = prop.parent;
                result = base.getProperty(path);
            }
        }
        return result;
    }
    /**
     * @return {?}
     */
    findRoot() {
        /** @type {?} */
        let property = this;
        while (property.parent !== null) {
            property = property.parent;
        }
        return (/** @type {?} */ (property));
    }
    /**
     * @private
     * @param {?} visible
     * @return {?}
     */
    setVisible(visible) {
        this._visible = visible;
        this._visibilityChanges.next(visible);
        this.updateValueAndValidity();
        if (this.parent) {
            this.parent.updateValueAndValidity(false, true);
        }
    }
    /**
     * Making use of the expression compiler for the <code>visibleIf</code> condition
     * @private
     * @param {?} sourceProperty
     * @param {?} targetProperty
     * @param {?} dependencyPath
     * @param {?=} value
     * @param {?=} expression
     * @return {?}
     */
    __evaluateVisibilityIf(sourceProperty, targetProperty, dependencyPath, value = '', expression = '') {
        try {
            /** @type {?} */
            let valid = false;
            if (expression.indexOf('$ANY$') !== -1) {
                valid = value && value.length > 0;
            }
            else if ((expression || []).toString().indexOf('$EXP$') === 0) {
                // since visibleIf condition values are an array... we must do this
                /** @type {?} */
                const expArray = Array.isArray(expression) ? expression : (expression ? [expression] : []);
                for (const expString of expArray) {
                    /** @type {?} */
                    const _expresssion = expString.substring('$EXP$'.length);
                    valid = true === this.expressionCompilerVisibiltyIf.evaluate(_expresssion, {
                        source: sourceProperty,
                        target: targetProperty
                    });
                    if (valid) {
                        break;
                    }
                }
            }
            else {
                valid = expression.indexOf(value) !== -1;
            }
            return valid;
        }
        catch (error) {
            console.error('Error processing "VisibileIf" expression for path: ', dependencyPath, `source - ${sourceProperty._canonicalPath}: `, sourceProperty, `target - ${targetProperty._canonicalPath}: `, targetProperty, 'value:', value, 'expression: ', expression, 'error: ', error);
        }
    }
    /**
     * @private
     * @return {?}
     */
    __bindVisibility() {
        /**
         * <pre>
         *     "oneOf":[{
         *         "path":["value","value"]
         *     },{
         *         "path":["value","value"]
         *     }]
         *     </pre>
         * <pre>
         *     "allOf":[{
         *         "path":["value","value"]
         *     },{
         *         "path":["value","value"]
         *     }]
         *     </pre>
         * @type {?}
         */
        const visibleIfProperty = this.schema.visibleIf;
        /** @type {?} */
        const visibleIfOf = (visibleIfProperty || {}).oneOf || (visibleIfProperty || {}).allOf;
        if (visibleIfOf) {
            for (const visibleIf of visibleIfOf) {
                if (typeof visibleIf === 'object' && Object.keys(visibleIf).length === 0) {
                    this.setVisible(false);
                }
                else if (visibleIf !== undefined) {
                    /** @type {?} */
                    const propertiesBinding = [];
                    for (const dependencyPath in visibleIf) {
                        if (visibleIf.hasOwnProperty(dependencyPath)) {
                            /** @type {?} */
                            const properties = this.findProperties(this, dependencyPath);
                            if ((properties || []).length) {
                                for (const property of properties) {
                                    if (property) {
                                        /** @type {?} */
                                        let valueCheck;
                                        if (this.schema.visibleIf.oneOf) {
                                            valueCheck = property.valueChanges.pipe(map((/**
                                             * @param {?} value
                                             * @return {?}
                                             */
                                            value => this.__evaluateVisibilityIf(this, property, dependencyPath, value, visibleIf[dependencyPath]))));
                                        }
                                        else if (this.schema.visibleIf.allOf) {
                                            /** @type {?} */
                                            const _chk = (/**
                                             * @param {?} value
                                             * @return {?}
                                             */
                                            (value) => {
                                                for (const item of this.schema.visibleIf.allOf) {
                                                    for (const depPath of Object.keys(item)) {
                                                        /** @type {?} */
                                                        const prop = this.searchProperty(depPath);
                                                        /** @type {?} */
                                                        const propVal = prop.value;
                                                        if (!this.__evaluateVisibilityIf(this, prop, dependencyPath, propVal, item[depPath])) {
                                                            return false;
                                                        }
                                                    }
                                                }
                                                return true;
                                            });
                                            valueCheck = property.valueChanges.pipe(map(_chk));
                                        }
                                        /** @type {?} */
                                        const visibilityCheck = property._visibilityChanges;
                                        /** @type {?} */
                                        const and = combineLatest([valueCheck, visibilityCheck], (/**
                                         * @param {?} v1
                                         * @param {?} v2
                                         * @return {?}
                                         */
                                        (v1, v2) => v1 && v2));
                                        propertiesBinding.push(and);
                                    }
                                }
                            }
                            else {
                                console.warn('Can\'t find property ' + dependencyPath + ' for visibility check of ' + this.path);
                                this.registerMissingVisibilityBinding(dependencyPath, this);
                                // not visible if not existent
                                this.setVisible(false);
                            }
                        }
                    }
                    combineLatest(propertiesBinding, (/**
                     * @param {...?} values
                     * @return {?}
                     */
                    (...values) => {
                        return values.indexOf(true) !== -1;
                    })).pipe(distinctUntilChanged()).subscribe((/**
                     * @param {?} visible
                     * @return {?}
                     */
                    (visible) => {
                        this.setVisible(visible);
                    }));
                }
            }
            return true;
        }
    }
    // A field is visible if AT LEAST ONE of the properties it depends on is visible AND has a value in the list
    /**
     * @return {?}
     */
    _bindVisibility() {
        if (this.__bindVisibility())
            return;
        /** @type {?} */
        let visibleIf = this.schema.visibleIf;
        if (typeof visibleIf === 'object' && Object.keys(visibleIf).length === 0) {
            this.setVisible(false);
        }
        else if (visibleIf !== undefined) {
            /** @type {?} */
            let propertiesBinding = [];
            for (let dependencyPath in visibleIf) {
                if (visibleIf.hasOwnProperty(dependencyPath)) {
                    /** @type {?} */
                    const properties = this.findProperties(this, dependencyPath);
                    if ((properties || []).length) {
                        for (const property of properties) {
                            if (property) {
                                /** @type {?} */
                                const valueCheck = property.valueChanges.pipe(map((/**
                                 * @param {?} value
                                 * @return {?}
                                 */
                                value => this.__evaluateVisibilityIf(this, property, dependencyPath, value, visibleIf[dependencyPath]))));
                                /** @type {?} */
                                const visibilityCheck = property._visibilityChanges;
                                /** @type {?} */
                                const and = combineLatest([valueCheck, visibilityCheck], (/**
                                 * @param {?} v1
                                 * @param {?} v2
                                 * @return {?}
                                 */
                                (v1, v2) => v1 && v2));
                                propertiesBinding.push(and);
                            }
                        }
                    }
                    else {
                        console.warn('Can\'t find property ' + dependencyPath + ' for visibility check of ' + this.path);
                        this.registerMissingVisibilityBinding(dependencyPath, this);
                        // not visible if not existent
                        this.setVisible(false);
                    }
                }
            }
            combineLatest(propertiesBinding, (/**
             * @param {...?} values
             * @return {?}
             */
            (...values) => {
                return values.indexOf(true) !== -1;
            })).pipe(distinctUntilChanged()).subscribe((/**
             * @param {?} visible
             * @return {?}
             */
            (visible) => {
                this.setVisible(visible);
            }));
        }
    }
    /**
     * @private
     * @param {?} dependencyPath
     * @param {?} formProperty
     * @return {?}
     */
    registerMissingVisibilityBinding(dependencyPath, formProperty) {
        formProperty._propertyBindingRegistry.getPropertyBindingsVisibility().add(dependencyPath, formProperty.path);
    }
    /**
     * Finds all <code>formProperties</code> from a path with wildcards.<br/>
     * e.g: <code>/garage/cars/&#42;/tires/&#42;/name</code><br/>
     * @param {?} target
     * @param {?} propertyPath
     * @return {?}
     */
    findProperties(target, propertyPath) {
        /** @type {?} */
        const props = [];
        /** @type {?} */
        const paths = this.findPropertyPaths(target, propertyPath);
        for (const path of paths) {
            /** @type {?} */
            const p = target.searchProperty(path);
            if (p) {
                props.push(p);
            }
        }
        return props;
    }
    /**
     * Creates canonical paths from a path with wildcards.
     * e.g:<br/>
     * From:<br/>
     * <code>/garage/cars/&#42;/tires/&#42;/name</code><br/>
     * it creates:<br/>
     * <code>/garage/cars/0/tires/0/name</code><br/>
     * <code>/garage/cars/0/tires/1/name</code><br/>
     * <code>/garage/cars/0/tires/2/name</code><br/>
     * <code>/garage/cars/0/tires/3/name</code><br/>
     * <code>/garage/cars/1/tires/0/name</code><br/>
     * <code>/garage/cars/2/tires/1/name</code><br/>
     * <code>/garage/cars/3/tires/2/name</code><br/>
     * <code>/garage/cars/3/tires/3/name</code><br/>
     * <code>/garage/cars/&#42;/tires/&#42;/name</code><br/>
     * <code>/garage/cars/&#42;/tires/2/name</code><br/>
     * <code>/garage/cars/&#42;/tires/3/name</code><br/>
     * <br/>etc...
     * @param {?} target
     * @param {?} path
     * @param {?=} parentPath
     * @return {?}
     */
    findPropertyPaths(target, path, parentPath) {
        /** @type {?} */
        const ix = path.indexOf('*');
        if (-1 !== ix) {
            /** @type {?} */
            const prePath = ix > -1 ? path.substring(0, ix - 1) : path;
            /** @type {?} */
            const subPath = ix > -1 ? path.substring(ix + 1) : path;
            /** @type {?} */
            const prop = target.searchProperty(prePath);
            /** @type {?} */
            let pathFound = [];
            if (prop instanceof PropertyGroup) {
                /** @type {?} */
                const arrProp = (/** @type {?} */ (prop.properties));
                for (let i = 0; i < arrProp.length; i++) {
                    /** @type {?} */
                    const curreItemPath = (parentPath || '') + prePath + (prePath.endsWith('/') ? '' : '/') + i + subPath;
                    /** @type {?} */
                    const curreItemPrePath = (parentPath || '') + prePath + i;
                    if (-1 === curreItemPath.indexOf('*')) {
                        pathFound.push(curreItemPath);
                    }
                    /** @type {?} */
                    const childrenPathFound = this.findPropertyPaths(arrProp[i], subPath, curreItemPrePath);
                    pathFound = pathFound.concat(childrenPathFound);
                }
            }
            return pathFound;
        }
        return [path];
    }
}
/**
 * @abstract
 */
class PropertyGroup extends FormProperty {
    constructor() {
        super(...arguments);
        this._properties = null;
        this._propertyProxyHandler = {
            /**
             * When a new item is added it will be checked for visibility updates to proceed <br/>
             * if any other field has a binding reference to it.<br/>
             * @param {?} target
             * @param {?} p
             * @param {?} value
             * @param {?} receiver
             * @return {?}
             */
            set(target, p, value, receiver) {
                /**
                 * 1) Make sure a canonical path is set
                 * @type {?}
                 */
                const assertCanonicalPath = (/**
                 * @param {?} propertyValue
                 * @return {?}
                 */
                (propertyValue) => {
                    /** @type {?} */
                    const formProperty = (/** @type {?} */ (propertyValue));
                    if (Array.isArray(target) && propertyValue instanceof FormProperty) {
                        /**
                         * Create a canonical path replacing the last '*' with the elements position in array
                         * \@param propertyPath
                         * \@param indexOfChild
                         * @type {?}
                         */
                        const getCanonicalPath = (/**
                         * @param {?} propertyPath
                         * @param {?} indexOfChild
                         * @return {?}
                         */
                        (propertyPath, indexOfChild) => {
                            /** @type {?} */
                            let pos;
                            if (propertyPath && -1 !== (pos = propertyPath.lastIndexOf('*'))) {
                                return propertyPath.substring(0, pos) + indexOfChild.toString() + propertyPath.substring(pos + 1);
                            }
                        });
                        if (formProperty) {
                            formProperty._canonicalPath = getCanonicalPath(formProperty._canonicalPath, (/** @type {?} */ (p)));
                        }
                    }
                    /** @type {?} */
                    const propertyGroup = (/** @type {?} */ (formProperty));
                    /** @type {?} */
                    const propertyGroupChildren = (/** @type {?} */ ((Array.isArray(propertyGroup.properties) ?
                        propertyGroup.properties :
                        Object.values(propertyGroup.properties || {}))));
                    if ((formProperty.path || '').endsWith('/*')) {
                        /**
                         * If it is an array, then all children canonical paths must be computed now.
                         * The children don't have the parent's path segment set yet,
                         * because they are created before the parent gets attached to its parent.
                         */
                        for (const child of propertyGroupChildren) {
                            child._canonicalPath = formProperty._canonicalPath + child._canonicalPath.substring(formProperty.path.length);
                        }
                    }
                    return { property: formProperty, children: propertyGroupChildren };
                });
                const { property, children } = assertCanonicalPath(value);
                /**
                 * 2) Add the new property before rebinding, so it can be found by <code>_bindVisibility</code>
                 * @type {?}
                 */
                const result = target[(/** @type {?} */ (p))] = value;
                /**
                 * 3) Re-bind the visibility bindings referencing to this canonical paths
                 * @type {?}
                 */
                const rebindVisibility = (/**
                 * @return {?}
                 */
                () => {
                    /** @type {?} */
                    const rebindAll = [property].concat(children);
                    /** @type {?} */
                    const findPropertiesToRebind = (/**
                     * @param {?} formProperty
                     * @return {?}
                     */
                    (formProperty) => {
                        /** @type {?} */
                        const propertyBindings = formProperty._propertyBindingRegistry.getPropertyBindingsVisibility();
                        /** @type {?} */
                        let rebind = [];
                        if (formProperty._canonicalPath) {
                            rebind = rebind.concat(rebind.concat(propertyBindings.findByDependencyPath(formProperty._canonicalPath) || []));
                            if (formProperty._canonicalPath.startsWith('/')) {
                                rebind = rebind.concat(rebind.concat(propertyBindings.findByDependencyPath(formProperty._canonicalPath.substring(1)) || []));
                            }
                        }
                        rebind = rebind.concat(propertyBindings.findByDependencyPath(formProperty.path) || []);
                        if (formProperty.path.startsWith('/')) {
                            rebind = rebind.concat(rebind.concat(propertyBindings.findByDependencyPath(formProperty.path.substring(1)) || []));
                        }
                        /** @type {?} */
                        const uniqueValues = {};
                        for (const item of rebind) {
                            uniqueValues[item] = item;
                        }
                        return Object.keys(uniqueValues);
                    });
                    for (const _property of rebindAll) {
                        if (_property instanceof FormProperty) {
                            try {
                                /** @type {?} */
                                const rebindPaths = findPropertiesToRebind(_property);
                                for (const rebindPropPath of rebindPaths) {
                                    /** @type {?} */
                                    const rebindProp = _property.searchProperty(rebindPropPath);
                                    rebindProp._bindVisibility();
                                }
                            }
                            catch (e) {
                                console.error('Rebinding visibility error at path:', _property.path, 'property:', _property, e);
                            }
                        }
                    }
                });
                rebindVisibility();
                return result;
            },
            /**
             * @param {?} target
             * @param {?} p
             * @param {?} receiver
             * @return {?}
             */
            get(target, p, receiver) {
                return target[(/** @type {?} */ (p))];
            },
            /**
             * @param {?} target
             * @param {?} p
             * @return {?}
             */
            deleteProperty(target, p) {
                return delete target[(/** @type {?} */ (p))];
            }
        };
    }
    /**
     * @return {?}
     */
    get properties() {
        return this._properties;
    }
    /**
     * @param {?} properties
     * @return {?}
     */
    set properties(properties) {
        /**
         * Override the setter to add an observer that notices when an item is added or removed.<br/>
         */
        this._properties = new Proxy(properties, this._propertyProxyHandler);
    }
    /**
     * @param {?} path
     * @return {?}
     */
    getProperty(path) {
        /** @type {?} */
        let subPathIdx = path.indexOf('/');
        /** @type {?} */
        let propertyId = subPathIdx !== -1 ? path.substr(0, subPathIdx) : path;
        /** @type {?} */
        let property = this.properties[propertyId];
        if (property !== null && subPathIdx !== -1 && property instanceof PropertyGroup) {
            /** @type {?} */
            let subPath = path.substr(subPathIdx + 1);
            property = ((/** @type {?} */ (property))).getProperty(subPath);
        }
        return property;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    forEachChild(fn) {
        for (let propertyId in this.properties) {
            if (this.properties.hasOwnProperty(propertyId)) {
                /** @type {?} */
                let property = this.properties[propertyId];
                fn(property, propertyId);
            }
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    forEachChildRecursive(fn) {
        this.forEachChild((/**
         * @param {?} child
         * @return {?}
         */
        (child) => {
            fn(child);
            if (child instanceof PropertyGroup) {
                ((/** @type {?} */ (child))).forEachChildRecursive(fn);
            }
        }));
    }
    /**
     * @return {?}
     */
    _bindVisibility() {
        super._bindVisibility();
        this._bindVisibilityRecursive();
    }
    /**
     * @private
     * @return {?}
     */
    _bindVisibilityRecursive() {
        this.forEachChildRecursive((/**
         * @param {?} property
         * @return {?}
         */
        (property) => {
            property._bindVisibility();
        }));
    }
    /**
     * @return {?}
     */
    isRoot() {
        return this === this.root;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const PROPERTY_TYPE_MAPPING = {};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FormPropertyFactory {
    /**
     * @param {?} schemaValidatorFactory
     * @param {?} validatorRegistry
     * @param {?} propertyBindingRegistry
     * @param {?} expressionCompilerFactory
     */
    constructor(schemaValidatorFactory, validatorRegistry, propertyBindingRegistry, expressionCompilerFactory) {
        this.schemaValidatorFactory = schemaValidatorFactory;
        this.validatorRegistry = validatorRegistry;
        this.propertyBindingRegistry = propertyBindingRegistry;
        this.expressionCompilerFactory = expressionCompilerFactory;
    }
    /**
     * @param {?} schema
     * @param {?=} parent
     * @param {?=} propertyId
     * @return {?}
     */
    createProperty(schema, parent = null, propertyId) {
        /** @type {?} */
        let newProperty = null;
        /** @type {?} */
        let path = '';
        /** @type {?} */
        let _canonicalPath = '';
        if (parent) {
            path += parent.path;
            if (parent.parent !== null) {
                path += '/';
                _canonicalPath += '/';
            }
            if (parent.type === 'object') {
                path += propertyId;
                _canonicalPath += propertyId;
            }
            else if (parent.type === 'array') {
                path += '*';
                _canonicalPath += '*';
            }
            else {
                throw 'Instanciation of a FormProperty with an unknown parent type: ' + parent.type;
            }
            _canonicalPath = (parent._canonicalPath || parent.path) + _canonicalPath;
        }
        else {
            path = '/';
            _canonicalPath = '/';
        }
        if (schema.$ref) {
            /** @type {?} */
            const refSchema = this.schemaValidatorFactory.getSchema(parent.root.schema, schema.$ref);
            newProperty = this.createProperty(refSchema, parent, path);
        }
        else {
            if (PROPERTY_TYPE_MAPPING[schema.type]) {
                if (schema.type === 'object' || schema.type === 'array') {
                    newProperty = PROPERTY_TYPE_MAPPING[schema.type](this.schemaValidatorFactory, this.validatorRegistry, this.expressionCompilerFactory, schema, parent, path, this);
                }
                else {
                    newProperty = PROPERTY_TYPE_MAPPING[schema.type](this.schemaValidatorFactory, this.validatorRegistry, this.expressionCompilerFactory, schema, parent, path);
                }
            }
            else {
                throw new TypeError(`Undefined type ${schema.type} (existing: ${Object.keys(PROPERTY_TYPE_MAPPING)})`);
            }
        }
        newProperty._propertyBindingRegistry = this.propertyBindingRegistry;
        newProperty._canonicalPath = _canonicalPath;
        if (newProperty instanceof PropertyGroup) {
            this.initializeRoot(newProperty);
        }
        return newProperty;
    }
    /**
     * @private
     * @param {?} rootProperty
     * @return {?}
     */
    initializeRoot(rootProperty) {
        rootProperty.reset(null, true);
        rootProperty._bindVisibility();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} o
 * @return {?}
 */
function isBlank(o) {
    return o === null || o === undefined;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} message
 * @param {?} path
 * @return {?}
 */
function formatMessage(message, path) {
    return `Parsing error on ${path}: ${message}`;
}
/**
 * @param {?} message
 * @param {?} path
 * @return {?}
 */
function schemaError(message, path) {
    /** @type {?} */
    let mesg = formatMessage(message, path);
    throw new Error(mesg);
}
/**
 * @param {?} message
 * @param {?} path
 * @return {?}
 */
function schemaWarning(message, path) {
    /** @type {?} */
    let mesg = formatMessage(message, path);
    throw new Error(mesg);
}
class SchemaPreprocessor {
    /**
     * @param {?} jsonSchema
     * @param {?=} path
     * @return {?}
     */
    static preprocess(jsonSchema, path = '/') {
        jsonSchema = jsonSchema || {};
        SchemaPreprocessor.normalizeExtensions(jsonSchema);
        if (jsonSchema.type === 'object') {
            SchemaPreprocessor.checkProperties(jsonSchema, path);
            SchemaPreprocessor.checkAndCreateFieldsets(jsonSchema, path);
        }
        else if (jsonSchema.type === 'array') {
            SchemaPreprocessor.checkItems(jsonSchema, path);
        }
        SchemaPreprocessor.normalizeWidget(jsonSchema);
        SchemaPreprocessor.recursiveCheck(jsonSchema, path);
    }
    /**
     * @private
     * @param {?} jsonSchema
     * @param {?} path
     * @return {?}
     */
    static checkProperties(jsonSchema, path) {
        if (isBlank(jsonSchema.properties)) {
            jsonSchema.properties = {};
            schemaWarning('Provided json schema does not contain a \'properties\' entry. Output schema will be empty', path);
        }
    }
    /**
     * @private
     * @param {?} jsonSchema
     * @param {?} path
     * @return {?}
     */
    static checkAndCreateFieldsets(jsonSchema, path) {
        if (jsonSchema.fieldsets === undefined) {
            if (jsonSchema.order !== undefined) {
                SchemaPreprocessor.replaceOrderByFieldsets(jsonSchema);
            }
            else {
                SchemaPreprocessor.createFieldsets(jsonSchema);
            }
        }
        SchemaPreprocessor.checkFieldsUsage(jsonSchema, path);
    }
    /**
     * @private
     * @param {?} jsonSchema
     * @param {?} path
     * @return {?}
     */
    static checkFieldsUsage(jsonSchema, path) {
        /** @type {?} */
        let fieldsId = Object.keys(jsonSchema.properties);
        /** @type {?} */
        let usedFields = {};
        for (let fieldset of jsonSchema.fieldsets) {
            for (let fieldId of fieldset.fields) {
                if (usedFields[fieldId] === undefined) {
                    usedFields[fieldId] = [];
                }
                usedFields[fieldId].push(fieldset.id);
            }
        }
        for (const fieldId of fieldsId) {
            /** @type {?} */
            const isRequired = jsonSchema.required && jsonSchema.required.indexOf(fieldId) > -1;
            if (isRequired && jsonSchema.properties[fieldId]) {
                jsonSchema.properties[fieldId].isRequired = true;
            }
            if (usedFields.hasOwnProperty(fieldId)) {
                if (usedFields[fieldId].length > 1) {
                    schemaError(`${fieldId} is referenced by more than one fieldset: ${usedFields[fieldId]}`, path);
                }
                delete usedFields[fieldId];
            }
            else if (isRequired) {
                schemaError(`${fieldId} is a required field but it is not referenced as part of a 'order' or a 'fieldset' property`, path);
            }
            else {
                delete jsonSchema[fieldId];
                schemaWarning(`Removing unreferenced field ${fieldId}`, path);
            }
        }
        for (let remainingfieldsId in usedFields) {
            if (usedFields.hasOwnProperty(remainingfieldsId)) {
                schemaWarning(`Referencing non-existent field ${remainingfieldsId} in one or more fieldsets`, path);
            }
        }
    }
    /**
     * @private
     * @param {?} jsonSchema
     * @return {?}
     */
    static createFieldsets(jsonSchema) {
        jsonSchema.order = Object.keys(jsonSchema.properties);
        SchemaPreprocessor.replaceOrderByFieldsets(jsonSchema);
    }
    /**
     * @private
     * @param {?} jsonSchema
     * @return {?}
     */
    static replaceOrderByFieldsets(jsonSchema) {
        jsonSchema.fieldsets = [{
                id: 'fieldset-default',
                title: jsonSchema.title || '',
                description: jsonSchema.description || '',
                name: jsonSchema.name || '',
                fields: jsonSchema.order
            }];
        delete jsonSchema.order;
    }
    /**
     * @private
     * @param {?} fieldSchema
     * @return {?}
     */
    static normalizeWidget(fieldSchema) {
        /** @type {?} */
        let widget = fieldSchema.widget;
        if (widget === undefined) {
            widget = { 'id': fieldSchema.type };
        }
        else if (typeof widget === 'string') {
            widget = { 'id': widget };
        }
        fieldSchema.widget = widget;
    }
    /**
     * @private
     * @param {?} jsonSchema
     * @param {?} path
     * @return {?}
     */
    static checkItems(jsonSchema, path) {
        if (jsonSchema.items === undefined) {
            schemaError('No \'items\' property in array', path);
        }
    }
    /**
     * @private
     * @param {?} jsonSchema
     * @param {?} path
     * @return {?}
     */
    static recursiveCheck(jsonSchema, path) {
        if (jsonSchema.type === 'object') {
            for (let fieldId in jsonSchema.properties) {
                if (jsonSchema.properties.hasOwnProperty(fieldId)) {
                    /** @type {?} */
                    let fieldSchema = jsonSchema.properties[fieldId];
                    SchemaPreprocessor.preprocess(fieldSchema, path + fieldId + '/');
                }
            }
            if (jsonSchema.hasOwnProperty('definitions')) {
                for (let fieldId in jsonSchema.definitions) {
                    if (jsonSchema.definitions.hasOwnProperty(fieldId)) {
                        /** @type {?} */
                        let fieldSchema = jsonSchema.definitions[fieldId];
                        SchemaPreprocessor.removeRecursiveRefProperties(fieldSchema, `#/definitions/${fieldId}`);
                        SchemaPreprocessor.preprocess(fieldSchema, path + fieldId + '/');
                    }
                }
            }
        }
        else if (jsonSchema.type === 'array') {
            SchemaPreprocessor.preprocess(jsonSchema.items, path + '*/');
        }
    }
    /**
     * @private
     * @param {?} jsonSchema
     * @param {?} definitionPath
     * @return {?}
     */
    static removeRecursiveRefProperties(jsonSchema, definitionPath) {
        // to avoid infinite loop
        if (jsonSchema.type === 'object') {
            for (let fieldId in jsonSchema.properties) {
                if (jsonSchema.properties.hasOwnProperty(fieldId)) {
                    if (jsonSchema.properties[fieldId].$ref
                        && jsonSchema.properties[fieldId].$ref === definitionPath) {
                        delete jsonSchema.properties[fieldId];
                    }
                    else if (jsonSchema.properties[fieldId].type === 'object') {
                        SchemaPreprocessor.removeRecursiveRefProperties(jsonSchema.properties[fieldId], definitionPath);
                    }
                }
            }
        }
    }
    /**
     * Enables alias names for JSON schema extensions.
     *
     * Copies the value of each alias JSON schema property
     * to the JSON schema property of ngx-schema-form.
     *
     * @private
     * @param {?} schema JSON schema to enable alias names.
     * @return {?}
     */
    static normalizeExtensions(schema) {
        /** @type {?} */
        const extensions = [
            { name: "fieldsets", regex: /^x-?field-?sets$/i },
            { name: "widget", regex: /^x-?widget$/i },
            { name: "visibleIf", regex: /^x-?visible-?if$/i }
        ];
        /** @type {?} */
        const keys = Object.keys(schema);
        for (let i = 0; i < keys.length; ++i) {
            /** @type {?} */
            let k = keys[i];
            /** @type {?} */
            let e = extensions.find((/**
             * @param {?} e
             * @return {?}
             */
            e => !!k.match(e.regex)));
            if (e) {
                /** @type {?} */
                let v = schema[k];
                /** @type {?} */
                let copy = JSON.parse(JSON.stringify(v));
                schema[e.name] = copy;
            }
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ValidatorRegistry {
    constructor() {
        this.validators = [];
    }
    /**
     * @param {?} path
     * @param {?} validator
     * @return {?}
     */
    register(path, validator) {
        this.validators[path] = validator;
    }
    /**
     * @param {?} path
     * @return {?}
     */
    get(path) {
        return this.validators[path];
    }
    /**
     * @return {?}
     */
    clear() {
        this.validators = [];
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BindingRegistry {
    constructor() {
        this.bindings = [];
    }
    /**
     * @return {?}
     */
    clear() {
        this.bindings = [];
    }
    /**
     * @param {?} path
     * @param {?} binding
     * @return {?}
     */
    register(path, binding) {
        this.bindings[path] = [].concat(binding);
    }
    /**
     * @param {?} path
     * @return {?}
     */
    get(path) {
        return this.bindings[path];
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class SchemaValidatorFactory {
    /**
     * Override this method to reset the schema validator instance.<br/>
     * This may be required since some schema validators keep a deep copy<br/>
     * of your schemas and changes at runtime are not recognized by the schema validator.<br/>
     * In this method you should either re-instantiate the schema validator or
     * clear its cache.<br/>
     * Example of re-instantiating schema validator
     * <code>
     *     reset(){
     *         this.zschema = new ZSchema({})
     *     }
     * </code>
     * <br/>
     * Since this method it self does nothing there is <br/>
     * no need to call the <code>super.reset()</code>
     * @return {?}
     */
    reset() {
    }
}
class ZSchemaValidatorFactory extends SchemaValidatorFactory {
    constructor() {
        super();
        this.createSchemaValidator();
    }
    /**
     * @private
     * @return {?}
     */
    createSchemaValidator() {
        this.zschema = new ZSchema({
            breakOnFirstError: false
        });
    }
    /**
     * @return {?}
     */
    reset() {
        this.createSchemaValidator();
    }
    /**
     * @param {?} schema
     * @return {?}
     */
    createValidatorFn(schema) {
        return (/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            if (schema.type === 'number' || schema.type === 'integer') {
                value = +value;
            }
            this.zschema.validate(value, schema);
            /** @type {?} */
            let err = this.zschema.getLastErrors();
            this.denormalizeRequiredPropertyPaths(err);
            return err || null;
        });
    }
    /**
     * @param {?} schema
     * @param {?} ref
     * @return {?}
     */
    getSchema(schema, ref) {
        // check definitions are valid
        /** @type {?} */
        const isValid = this.zschema.compileSchema(schema);
        if (isValid) {
            return this.getDefinition(schema, ref);
        }
        else {
            throw this.zschema.getLastError();
        }
    }
    /**
     * @private
     * @param {?} err
     * @return {?}
     */
    denormalizeRequiredPropertyPaths(err) {
        if (err && err.length) {
            err = err.map((/**
             * @param {?} error
             * @return {?}
             */
            error => {
                if (error.path === '#/' && error.code === 'OBJECT_MISSING_REQUIRED_PROPERTY') {
                    error.path = `${error.path}${error.params[0]}`;
                }
                return error;
            }));
        }
    }
    /**
     * @private
     * @param {?} schema
     * @param {?} ref
     * @return {?}
     */
    getDefinition(schema, ref) {
        /** @type {?} */
        let foundSchema = schema;
        ref.split('/').slice(1).forEach((/**
         * @param {?} ptr
         * @return {?}
         */
        ptr => {
            if (ptr) {
                foundSchema = foundSchema[ptr];
            }
        }));
        return foundSchema;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class WidgetRegistry {
    constructor() {
        this.widgets = {};
    }
    /**
     * @param {?} widget
     * @return {?}
     */
    setDefaultWidget(widget) {
        this.defaultWidget = widget;
    }
    /**
     * @return {?}
     */
    getDefaultWidget() {
        return this.defaultWidget;
    }
    /**
     * @param {?} type
     * @return {?}
     */
    hasWidget(type) {
        return this.widgets.hasOwnProperty(type);
    }
    /**
     * @param {?} type
     * @param {?} widget
     * @return {?}
     */
    register(type, widget) {
        this.widgets[type] = widget;
    }
    /**
     * @param {?} type
     * @return {?}
     */
    getWidgetType(type) {
        if (this.hasWidget(type)) {
            return this.widgets[type];
        }
        return this.defaultWidget;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class WidgetFactory {
    /**
     * @param {?} registry
     * @param {?} resolver
     */
    constructor(registry, resolver) {
        this.registry = registry;
        this.resolver = resolver;
    }
    /**
     * @param {?} container
     * @param {?} type
     * @return {?}
     */
    createWidget(container, type) {
        /** @type {?} */
        let componentClass = this.registry.getWidgetType(type);
        /** @type {?} */
        let componentFactory = this.resolver.resolveComponentFactory(componentClass);
        return container.createComponent(componentFactory);
    }
}
WidgetFactory.decorators = [
    { type: Injectable }
];
/** @nocollapse */
WidgetFactory.ctorParameters = () => [
    { type: WidgetRegistry },
    { type: ComponentFactoryResolver }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TerminatorService {
    constructor() {
        this.onDestroy = new Subject();
    }
    /**
     * @return {?}
     */
    destroy() {
        this.onDestroy.next(true);
    }
}
TerminatorService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
TerminatorService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * General purpose propery binding registry
 */
class PropertyBindingRegistry {
    constructor() {
        this.bindings = {};
    }
    /**
     * @param {?} type
     * @return {?}
     */
    getPropertyBindings(type) {
        this.bindings[type] = this.bindings[type] || new PropertyBindings();
        return this.bindings[type];
    }
    /**
     * @return {?}
     */
    getPropertyBindingsVisibility() {
        return this.getPropertyBindings(PropertyBindingTypes.visibility);
    }
}
/** @enum {number} */
const PropertyBindingTypes = {
    visibility: 0,
};
PropertyBindingTypes[PropertyBindingTypes.visibility] = 'visibility';
/**
 * Storage that holds all bindings that are property paths related.<br/>
 */
class PropertyBindings {
    constructor() {
        this.sourcesIndex = new SimplePropertyIndexer();
        this.dependenciesIndex = new SimplePropertyIndexer();
    }
    /**
     * @param {?} dependencyPath
     * @param {?} sourcePropertyPath
     * @return {?}
     */
    add(dependencyPath, sourcePropertyPath) {
        this.sourcesIndex.store(sourcePropertyPath, dependencyPath);
        this.dependenciesIndex.store(dependencyPath, sourcePropertyPath);
    }
    /**
     * @param {?} dependencyPath
     * @return {?}
     */
    findByDependencyPath(dependencyPath) {
        /** @type {?} */
        const result = this.dependenciesIndex.find(dependencyPath);
        result.results = result.results || [];
        /** @type {?} */
        let values = [];
        for (const res of result.results) {
            values = values.concat(Object.keys(res.value));
        }
        return result.found ? values : [];
    }
    /**
     * @param {?} sourcePropertyPath
     * @return {?}
     */
    getBySourcePropertyPath(sourcePropertyPath) {
        /** @type {?} */
        const result = this.sourcesIndex.find(sourcePropertyPath);
        result.results = result.results || [];
        /** @type {?} */
        let values = [];
        for (const res of result.results) {
            values = values.concat(Object.keys(res.value));
        }
        return result.found ? values : [];
    }
    /**
     * @param {?} path
     * @return {?}
     */
    createPathIndex(path) {
        return path.split('/');
    }
}
/**
 * Simple indexer to store property paths
 */
class SimplePropertyIndexer {
    constructor() {
        this.index = {};
        this.findOnlyWithValue = true;
    }
    /**
     * @private
     * @param {?} path
     * @return {?}
     */
    _createPathIndex(path) {
        return path
            .replace(new RegExp('//', 'g'), '/')
            .replace(new RegExp('^/', 'g'), '')
            .split('/').filter((/**
         * @param {?} item
         * @return {?}
         */
        item => item));
    }
    /**
     * @param {?} propertyPath
     * @param {?=} value
     * @return {?}
     */
    store(propertyPath, value) {
        this._storeIndex(this._createPathIndex(propertyPath), value);
    }
    /**
     * @private
     * @param {?} pathIndex
     * @param {?=} value
     * @return {?}
     */
    _storeIndex(pathIndex, value) {
        /** @type {?} */
        let indexPos = this.index;
        for (const key of pathIndex) {
            indexPos[key] = indexPos[key] || {};
            indexPos = indexPos[key];
        }
        if (indexPos && value) {
            indexPos[SimplePropertyIndexer.MARKER] = indexPos[SimplePropertyIndexer.MARKER] || {};
            indexPos[SimplePropertyIndexer.MARKER][value] = value;
        }
    }
    /**
     * Find path in index.<br/>
     * Will find path like:<br/>
     * <ul>
     *     <li>/property/0/prop</li>
     *     <li>/property/0/prop/2/test</li>
     *     <li>/property/0/prop/&#42;/test</li>
     *     <li>/property/&#42;/prop/1/test</li>
     *     <li>/property/&#42;/prop/&#42;/test</li>
     *     <li>/property/1/prop/&#42;/test</li>
     *  </ul>
     * @param {?} path
     * @return {?}
     */
    find(path) {
        return this._findInIndex(this._createPathIndex(path));
    }
    /**
     * @param {?} path
     * @return {?}
     */
    _findInIndex(path) {
        /** @type {?} */
        const ixRes = { target: path, found: false, results: [] };
        this.__findIndex(ixRes, path, this.index, []);
        return ixRes;
    }
    /**
     * @param {?} indexerResults
     * @param {?} path
     * @param {?} index
     * @param {?=} parent
     * @return {?}
     */
    __findIndex(indexerResults, path, index, parent) {
        /** @type {?} */
        const p = parent || [];
        /** @type {?} */
        const segment = path[0];
        /** @type {?} */
        const wild = ('*' === segment) ? Object.keys(index) : [];
        /** @type {?} */
        const _keys = ((/** @type {?} */ ((Array.isArray(segment) ? segment : [segment])))).concat(wild);
        /** @type {?} */
        const keys = _keys.filter((/**
         * @param {?} item
         * @param {?} pos
         * @return {?}
         */
        (item, pos) => '*' !== item && _keys.indexOf(item) === pos));
        if (index['*']) {
            keys.push('*');
        }
        /** @type {?} */
        let paths = [];
        for (const key of keys) {
            /** @type {?} */
            const restPath = path.slice(1);
            /** @type {?} */
            const restIndex = index[key];
            /** @type {?} */
            const restParent = p.concat(key);
            if (path.length === 1) { // collect only the full paths
                if (!this.findOnlyWithValue || (restIndex && restIndex[SimplePropertyIndexer.MARKER])) {
                    indexerResults.results = indexerResults.results || [];
                    indexerResults.results.push({
                        path: restParent,
                        value: restIndex[SimplePropertyIndexer.MARKER]
                    });
                    paths.push(restParent);
                    indexerResults.found = indexerResults.results.length > 0;
                }
            }
            if (!restPath || !restPath.length || !restIndex) {
                break;
            }
            /** @type {?} */
            const restPaths = this.__findIndex(indexerResults, restPath, restIndex, restParent);
            paths = paths.concat(restPaths);
        }
        return paths;
    }
}
SimplePropertyIndexer.MARKER = '$____value';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class ExpressionCompilerFactory {
}
class JEXLExpressionCompilerFactory extends ExpressionCompilerFactory {
    /**
     * @return {?}
     */
    createExpressionCompiler() {
        return new JEXLExpressionCompiler();
    }
    /**
     * @return {?}
     */
    createExpressionCompilerVisibilityIf() {
        return new JEXLExpressionCompilerVisibiltyIf();
    }
}
class JEXLExpressionCompiler {
    /**
     * @param {?} expression
     * @param {?=} context
     * @return {?}
     */
    evaluate(expression, context = {}) {
        return new Jexl().evalSync(expression, context);
    }
}
class JEXLExpressionCompilerVisibiltyIf {
    /**
     * @param {?} expression
     * @param {?=} context
     * @return {?}
     */
    evaluate(expression, context = { source: (/** @type {?} */ ({})), target: (/** @type {?} */ ({})) }) {
        return new Jexl().evalSync(expression, context);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} schemaValidatorFactory
 * @param {?} validatorRegistry
 * @param {?} propertyBindingRegistry
 * @param {?} expressionCompilerFactory
 * @return {?}
 */
function useFactory(schemaValidatorFactory, validatorRegistry, propertyBindingRegistry, expressionCompilerFactory) {
    return new FormPropertyFactory(schemaValidatorFactory, validatorRegistry, propertyBindingRegistry, expressionCompilerFactory);
}
class FormComponent {
    /**
     * @param {?} formPropertyFactory
     * @param {?} actionRegistry
     * @param {?} validatorRegistry
     * @param {?} bindingRegistry
     * @param {?} cdr
     * @param {?} terminator
     */
    constructor(formPropertyFactory, actionRegistry, validatorRegistry, bindingRegistry, cdr, terminator) {
        this.formPropertyFactory = formPropertyFactory;
        this.actionRegistry = actionRegistry;
        this.validatorRegistry = validatorRegistry;
        this.bindingRegistry = bindingRegistry;
        this.cdr = cdr;
        this.terminator = terminator;
        this.schema = null;
        this.actions = {};
        this.validators = {};
        this.bindings = {};
        this.onChange = new EventEmitter();
        this.modelChange = new EventEmitter();
        this.isValid = new EventEmitter();
        this.onErrorChange = new EventEmitter();
        this.onErrorsChange = new EventEmitter();
        this.rootProperty = null;
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    writeValue(obj) {
        if (this.rootProperty) {
            this.rootProperty.reset(obj, false);
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
        if (this.rootProperty) {
            this.rootProperty.valueChanges.subscribe(this.onValueChanges.bind(this));
        }
    }
    // TODO implement
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
    }
    // TODO implement
    // setDisabledState(isDisabled: boolean)?: void
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.validators) {
            this.setValidators();
        }
        if (changes.actions) {
            this.setActions();
        }
        if (changes.bindings) {
            this.setBindings();
        }
        if (this.schema && !this.schema.type) {
            this.schema.type = 'object';
        }
        if (this.schema && changes.schema) {
            if (!changes.schema.firstChange) {
                this.terminator.destroy();
            }
            SchemaPreprocessor.preprocess(this.schema);
            this.rootProperty = this.formPropertyFactory.createProperty(this.schema);
            if (this.model) ;
            this.rootProperty.valueChanges.subscribe(this.onValueChanges.bind(this));
            this.rootProperty.errorsChanges.subscribe((/**
             * @param {?} value
             * @return {?}
             */
            value => {
                this.onErrorChange.emit({ value: value });
                this.isValid.emit(!(value && value.length));
            }));
        }
        if (this.schema && (changes.model || changes.schema)) {
            this.rootProperty.reset(this.model, false);
            this.cdr.detectChanges();
        }
    }
    /**
     * @private
     * @return {?}
     */
    setValidators() {
        this.validatorRegistry.clear();
        if (this.validators) {
            for (const validatorId in this.validators) {
                if (this.validators.hasOwnProperty(validatorId)) {
                    this.validatorRegistry.register(validatorId, this.validators[validatorId]);
                }
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    setActions() {
        this.actionRegistry.clear();
        if (this.actions) {
            for (const actionId in this.actions) {
                if (this.actions.hasOwnProperty(actionId)) {
                    this.actionRegistry.register(actionId, this.actions[actionId]);
                }
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    setBindings() {
        this.bindingRegistry.clear();
        if (this.bindings) {
            for (const bindingPath in this.bindings) {
                if (this.bindings.hasOwnProperty(bindingPath)) {
                    this.bindingRegistry.register(bindingPath, this.bindings[bindingPath]);
                }
            }
        }
    }
    /**
     * @return {?}
     */
    reset() {
        this.rootProperty.reset(null, true);
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    setModel(value) {
        if (this.model) {
            Object.assign(this.model, value);
        }
        else {
            this.model = value;
        }
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    onValueChanges(value) {
        if (this.onChangeCallback) {
            this.setModel(value);
            this.onChangeCallback(value);
        }
        // two way binding is used
        if (this.modelChange.observers.length > 0) {
            if (!this.onChangeCallback) {
                this.setModel(value);
            }
        }
        this.onChange.emit({ value: value });
    }
}
FormComponent.decorators = [
    { type: Component, args: [{
                selector: 'sf-form',
                template: `
    <form *ngIf="rootProperty" [attr.name]="rootProperty.rootName" [attr.id]="rootProperty.rootName">
      <sf-form-element [formProperty]="rootProperty"></sf-form-element>
    </form>`,
                providers: [
                    ActionRegistry,
                    ValidatorRegistry,
                    PropertyBindingRegistry,
                    BindingRegistry,
                    SchemaPreprocessor,
                    WidgetFactory,
                    {
                        provide: FormPropertyFactory,
                        useFactory: useFactory,
                        deps: [SchemaValidatorFactory, ValidatorRegistry, PropertyBindingRegistry, ExpressionCompilerFactory]
                    },
                    TerminatorService,
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: FormComponent,
                        multi: true
                    }
                ]
            }] }
];
/** @nocollapse */
FormComponent.ctorParameters = () => [
    { type: FormPropertyFactory },
    { type: ActionRegistry },
    { type: ValidatorRegistry },
    { type: BindingRegistry },
    { type: ChangeDetectorRef },
    { type: TerminatorService }
];
FormComponent.propDecorators = {
    schema: [{ type: Input }],
    model: [{ type: Input }],
    actions: [{ type: Input }],
    validators: [{ type: Input }],
    bindings: [{ type: Input }],
    onChange: [{ type: Output }],
    modelChange: [{ type: Output }],
    isValid: [{ type: Output }],
    onErrorChange: [{ type: Output }],
    onErrorsChange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FormElementComponent {
    /**
     * @param {?} actionRegistry
     * @param {?} bindingRegistry
     * @param {?} renderer
     * @param {?} elementRef
     */
    constructor(actionRegistry, bindingRegistry, renderer, elementRef) {
        this.actionRegistry = actionRegistry;
        this.bindingRegistry = bindingRegistry;
        this.renderer = renderer;
        this.elementRef = elementRef;
        this.control = new FormControl('', (/**
         * @return {?}
         */
        () => null));
        this.widget = null;
        this.buttons = [];
        this.unlisten = [];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.parseButtons();
        this.setupBindings();
    }
    /**
     * @private
     * @return {?}
     */
    setupBindings() {
        /** @type {?} */
        const bindings = this.bindingRegistry.get(this.formProperty.path);
        if ((bindings || []).length) {
            bindings.forEach((/**
             * @param {?} binding
             * @return {?}
             */
            (binding) => {
                for (const eventId in binding) {
                    this.createBinding(eventId, binding[eventId]);
                }
            }));
        }
    }
    /**
     * @private
     * @param {?} eventId
     * @param {?} listener
     * @return {?}
     */
    createBinding(eventId, listener) {
        this.unlisten.push(this.renderer.listen(this.elementRef.nativeElement, eventId, (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            if (listener instanceof Function) {
                listener(event, this.formProperty);
            }
            else {
                console.warn('Calling non function handler for eventId ' + eventId + ' for path ' + this.formProperty.path);
            }
        })));
    }
    /**
     * @private
     * @return {?}
     */
    parseButtons() {
        if (this.formProperty.schema.buttons !== undefined) {
            this.buttons = this.formProperty.schema.buttons;
            for (let button of this.buttons) {
                this.createButtonCallback(button);
            }
        }
    }
    /**
     * @private
     * @param {?} button
     * @return {?}
     */
    createButtonCallback(button) {
        button.action = (/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            /** @type {?} */
            let action;
            if (button.id && (action = this.actionRegistry.get(button.id))) {
                if (action) {
                    action(this.formProperty, button.parameters);
                }
            }
            e.preventDefault();
        });
    }
    /**
     * @param {?} widget
     * @return {?}
     */
    onWidgetInstanciated(widget) {
        this.widget = widget;
        /** @type {?} */
        let id = this.formProperty.canonicalPathNotation || 'field' + (FormElementComponent.counter++);
        if (this.formProperty.root.rootName) {
            id = `${this.formProperty.root.rootName}:${id}`;
        }
        this.widget.formProperty = this.formProperty;
        this.widget.schema = this.formProperty.schema;
        this.widget.name = id;
        this.widget.id = id;
        this.widget.control = this.control;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.unlisten) {
            this.unlisten.forEach((/**
             * @param {?} item
             * @return {?}
             */
            (item) => {
                item();
            }));
        }
    }
}
FormElementComponent.counter = 0;
FormElementComponent.decorators = [
    { type: Component, args: [{
                selector: 'sf-form-element',
                template: `
    <div *ngIf="formProperty.visible"
         [class.has-error]="!control.valid"
         [class.has-success]="control.valid">
      <sf-widget-chooser
        (widgetInstanciated)="onWidgetInstanciated($event)"
        [widgetInfo]="formProperty.schema.widget">
      </sf-widget-chooser>
      <sf-form-element-action *ngFor="let button of buttons" [button]="button" [formProperty]="formProperty"></sf-form-element-action>
    </div>`
            }] }
];
/** @nocollapse */
FormElementComponent.ctorParameters = () => [
    { type: ActionRegistry },
    { type: BindingRegistry },
    { type: Renderer2 },
    { type: ElementRef }
];
FormElementComponent.propDecorators = {
    formProperty: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FormElementComponentAction {
    /**
     * @param {?=} widgetFactory
     * @param {?=} terminator
     */
    constructor(widgetFactory = null, terminator) {
        this.widgetFactory = widgetFactory;
        this.terminator = terminator;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.subs = this.terminator.onDestroy.subscribe((/**
         * @param {?} destroy
         * @return {?}
         */
        destroy => {
            if (destroy) {
                this.ref.destroy();
            }
        }));
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this.ref = this.widgetFactory.createWidget(this.container, this.button.widget || 'button');
        this.ref.instance.button = this.button;
        this.ref.instance.formProperty = this.formProperty;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subs.unsubscribe();
    }
}
FormElementComponentAction.decorators = [
    { type: Component, args: [{
                selector: 'sf-form-element-action',
                template: '<ng-template #target></ng-template>'
            }] }
];
/** @nocollapse */
FormElementComponentAction.ctorParameters = () => [
    { type: WidgetFactory },
    { type: TerminatorService }
];
FormElementComponentAction.propDecorators = {
    button: [{ type: Input }],
    formProperty: [{ type: Input }],
    container: [{ type: ViewChild, args: ['target', { read: ViewContainerRef, static: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class WidgetChooserComponent {
    /**
     * @param {?=} widgetFactory
     * @param {?=} cdr
     * @param {?=} terminator
     */
    constructor(widgetFactory = null, cdr, terminator) {
        this.widgetFactory = widgetFactory;
        this.cdr = cdr;
        this.terminator = terminator;
        this.widgetInstanciated = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.subs = this.terminator.onDestroy.subscribe((/**
         * @param {?} destroy
         * @return {?}
         */
        destroy => {
            if (destroy) {
                this.ref.destroy();
            }
        }));
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this.ref = this.widgetFactory.createWidget(this.container, this.widgetInfo.id);
        this.widgetInstanciated.emit(this.ref.instance);
        this.widgetInstance = this.ref.instance;
        this.cdr.detectChanges();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subs.unsubscribe();
    }
}
WidgetChooserComponent.decorators = [
    { type: Component, args: [{
                selector: 'sf-widget-chooser',
                template: `<div #target></div>`
            }] }
];
/** @nocollapse */
WidgetChooserComponent.ctorParameters = () => [
    { type: WidgetFactory },
    { type: ChangeDetectorRef },
    { type: TerminatorService }
];
WidgetChooserComponent.propDecorators = {
    widgetInfo: [{ type: Input }],
    widgetInstanciated: [{ type: Output }],
    container: [{ type: ViewChild, args: ['target', { read: ViewContainerRef, static: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class AtomicProperty extends FormProperty {
    /**
     * @param {?} value
     * @param {?=} onlySelf
     * @return {?}
     */
    setValue(value, onlySelf = false) {
        this._value = value;
        this.updateValueAndValidity(onlySelf, true);
    }
    /**
     * @param {?=} value
     * @param {?=} onlySelf
     * @return {?}
     */
    reset(value = null, onlySelf = true) {
        this.resetValue(value);
        this.updateValueAndValidity(onlySelf, true);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    resetValue(value) {
        if (value === null) {
            if (this.schema.default !== undefined) {
                value = this.schema.default;
            }
            else {
                value = this.fallbackValue();
            }
        }
        this._value = value;
    }
    /**
     * @return {?}
     */
    _hasValue() {
        return this.fallbackValue() !== this.value;
    }
    /**
     * @return {?}
     */
    _updateValue() {
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ObjectProperty extends PropertyGroup {
    /**
     * @param {?} formPropertyFactory
     * @param {?} schemaValidatorFactory
     * @param {?} validatorRegistry
     * @param {?} expressionCompilerFactory
     * @param {?} schema
     * @param {?} parent
     * @param {?} path
     */
    constructor(formPropertyFactory, schemaValidatorFactory, validatorRegistry, expressionCompilerFactory, schema, parent, path) {
        super(schemaValidatorFactory, validatorRegistry, expressionCompilerFactory, schema, parent, path);
        this.formPropertyFactory = formPropertyFactory;
        this.propertiesId = [];
        this.createProperties();
    }
    /**
     * @param {?} value
     * @param {?} onlySelf
     * @return {?}
     */
    setValue(value, onlySelf) {
        for (const propertyId in value) {
            if (value.hasOwnProperty(propertyId)) {
                this.properties[propertyId].setValue(value[propertyId], true);
            }
        }
        this.updateValueAndValidity(onlySelf, true);
    }
    /**
     * @param {?} value
     * @param {?=} onlySelf
     * @return {?}
     */
    reset(value, onlySelf = true) {
        value = value || this.schema.default || {};
        this.resetProperties(value);
        this.updateValueAndValidity(onlySelf, true);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    resetProperties(value) {
        for (const propertyId in this.schema.properties) {
            if (this.schema.properties.hasOwnProperty(propertyId)) {
                this.properties[propertyId].reset(value[propertyId], true);
            }
        }
    }
    /**
     * @return {?}
     */
    createProperties() {
        this.properties = {};
        this.propertiesId = [];
        for (const propertyId in this.schema.properties) {
            if (this.schema.properties.hasOwnProperty(propertyId)) {
                /** @type {?} */
                const propertySchema = this.schema.properties[propertyId];
                this.properties[propertyId] = this.formPropertyFactory.createProperty(propertySchema, this, propertyId);
                this.propertiesId.push(propertyId);
            }
        }
    }
    /**
     * @return {?}
     */
    _hasValue() {
        return !!Object.keys(this.value).length;
    }
    /**
     * @return {?}
     */
    _updateValue() {
        this.reduceValue();
    }
    /**
     * @return {?}
     */
    _runValidation() {
        super._runValidation();
        if (this._errors) {
            this._errors.forEach((/**
             * @param {?} error
             * @return {?}
             */
            error => {
                /** @type {?} */
                const prop = this.searchProperty(error.path.slice(1));
                if (prop) {
                    prop.extendErrors(error);
                }
            }));
        }
    }
    /**
     * @private
     * @return {?}
     */
    reduceValue() {
        /** @type {?} */
        const value = {};
        this.forEachChild((/**
         * @param {?} property
         * @param {?} propertyId
         * @return {?}
         */
        (property, propertyId) => {
            if (property.visible && property._hasValue()) {
                value[propertyId] = property.value;
            }
        }));
        this._value = value;
    }
}
PROPERTY_TYPE_MAPPING.object = (/**
 * @param {?} schemaValidatorFactory
 * @param {?} validatorRegistry
 * @param {?} expressionCompilerFactory
 * @param {?} schema
 * @param {?} parent
 * @param {?} path
 * @param {?} formPropertyFactory
 * @return {?}
 */
(schemaValidatorFactory, validatorRegistry, expressionCompilerFactory, schema, parent, path, formPropertyFactory) => {
    return new ObjectProperty(formPropertyFactory, schemaValidatorFactory, validatorRegistry, expressionCompilerFactory, schema, parent, path);
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ArrayProperty extends PropertyGroup {
    /**
     * @param {?} formPropertyFactory
     * @param {?} schemaValidatorFactory
     * @param {?} validatorRegistry
     * @param {?} expressionCompilerFactory
     * @param {?} schema
     * @param {?} parent
     * @param {?} path
     */
    constructor(formPropertyFactory, schemaValidatorFactory, validatorRegistry, expressionCompilerFactory, schema, parent, path) {
        super(schemaValidatorFactory, validatorRegistry, expressionCompilerFactory, schema, parent, path);
        this.formPropertyFactory = formPropertyFactory;
    }
    /**
     * @param {?=} value
     * @return {?}
     */
    addItem(value = null) {
        /** @type {?} */
        let newProperty = this.addProperty();
        newProperty.reset(value, false);
        return newProperty;
    }
    /**
     * @private
     * @return {?}
     */
    addProperty() {
        /** @type {?} */
        let newProperty = this.formPropertyFactory.createProperty(this.schema.items, this);
        ((/** @type {?} */ (this.properties))).push(newProperty);
        return newProperty;
    }
    /**
     * @param {?} item
     * @return {?}
     */
    removeItem(item) {
        this.properties = ((/** @type {?} */ (this.properties))).filter((/**
         * @param {?} i
         * @return {?}
         */
        i => i !== item));
        this.updateValueAndValidity(false, true);
    }
    /**
     * @param {?} value
     * @param {?} onlySelf
     * @return {?}
     */
    setValue(value, onlySelf) {
        this.createProperties();
        this.resetProperties(value);
        this.updateValueAndValidity(onlySelf, true);
    }
    /**
     * @return {?}
     */
    _hasValue() {
        return true;
    }
    /**
     * @return {?}
     */
    _updateValue() {
        this.reduceValue();
    }
    /**
     * @private
     * @return {?}
     */
    reduceValue() {
        /** @type {?} */
        const value = [];
        this.forEachChild((/**
         * @param {?} property
         * @param {?} _
         * @return {?}
         */
        (property, _) => {
            if (property.visible && property._hasValue()) {
                value.push(property.value);
            }
        }));
        this._value = value;
    }
    /**
     * @param {?} value
     * @param {?=} onlySelf
     * @return {?}
     */
    reset(value, onlySelf = true) {
        value = value || this.schema.default || [];
        this.properties = [];
        this.resetProperties(value);
        this.updateValueAndValidity(onlySelf, true);
    }
    /**
     * @private
     * @return {?}
     */
    createProperties() {
        this.properties = [];
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    resetProperties(value) {
        for (let idx in value) {
            if (value.hasOwnProperty(idx)) {
                /** @type {?} */
                let property = this.addProperty();
                property.reset(value[idx], true);
            }
        }
    }
}
PROPERTY_TYPE_MAPPING.array = (/**
 * @param {?} schemaValidatorFactory
 * @param {?} validatorRegistry
 * @param {?} expressionCompilerFactory
 * @param {?} schema
 * @param {?} parent
 * @param {?} path
 * @param {?} formPropertyFactory
 * @return {?}
 */
(schemaValidatorFactory, validatorRegistry, expressionCompilerFactory, schema, parent, path, formPropertyFactory) => {
    return new ArrayProperty(formPropertyFactory, schemaValidatorFactory, validatorRegistry, expressionCompilerFactory, schema, parent, path);
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StringProperty extends AtomicProperty {
    /**
     * @return {?}
     */
    fallbackValue() {
        return '';
    }
}
PROPERTY_TYPE_MAPPING.string = (/**
 * @param {?} schemaValidatorFactory
 * @param {?} validatorRegistry
 * @param {?} expressionCompilerFactory
 * @param {?} schema
 * @param {?} parent
 * @param {?} path
 * @return {?}
 */
(schemaValidatorFactory, validatorRegistry, expressionCompilerFactory, schema, parent, path) => {
    return new StringProperty(schemaValidatorFactory, validatorRegistry, expressionCompilerFactory, schema, parent, path);
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BooleanProperty extends AtomicProperty {
    /**
     * @return {?}
     */
    fallbackValue() {
        return null;
    }
}
PROPERTY_TYPE_MAPPING.boolean = (/**
 * @param {?} schemaValidatorFactory
 * @param {?} validatorRegistry
 * @param {?} expressionCompilerFactory
 * @param {?} schema
 * @param {?} parent
 * @param {?} path
 * @return {?}
 */
(schemaValidatorFactory, validatorRegistry, expressionCompilerFactory, schema, parent, path) => {
    return new BooleanProperty(schemaValidatorFactory, validatorRegistry, expressionCompilerFactory, schema, parent, path);
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NumberProperty extends AtomicProperty {
    /**
     * @return {?}
     */
    fallbackValue() {
        return null;
    }
    /**
     * @param {?} value
     * @param {?=} onlySelf
     * @return {?}
     */
    setValue(value, onlySelf = false) {
        if (typeof value === 'string') {
            if (value.length) {
                value = value.indexOf('.') > -1 ? parseFloat(value) : parseInt(value, 10);
            }
            else {
                value = null;
            }
        }
        this._value = value;
        this.updateValueAndValidity(onlySelf, true);
    }
}
PROPERTY_TYPE_MAPPING.integer = (/**
 * @param {?} schemaValidatorFactory
 * @param {?} validatorRegistry
 * @param {?} expressionCompilerFactory
 * @param {?} schema
 * @param {?} parent
 * @param {?} path
 * @return {?}
 */
(schemaValidatorFactory, validatorRegistry, expressionCompilerFactory, schema, parent, path) => {
    return new NumberProperty(schemaValidatorFactory, validatorRegistry, expressionCompilerFactory, schema, parent, path);
});
PROPERTY_TYPE_MAPPING.number = (/**
 * @param {?} schemaValidatorFactory
 * @param {?} validatorRegistry
 * @param {?} expressionCompilerFactory
 * @param {?} schema
 * @param {?} parent
 * @param {?} path
 * @return {?}
 */
(schemaValidatorFactory, validatorRegistry, expressionCompilerFactory, schema, parent, path) => {
    return new NumberProperty(schemaValidatorFactory, validatorRegistry, expressionCompilerFactory, schema, parent, path);
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 * @template T
 */
class Widget {
    constructor() {
        this.id = '';
        this.name = '';
        this.schema = {};
    }
}
class ControlWidget extends Widget {
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        /** @type {?} */
        const control = this.control;
        this.formProperty.valueChanges.subscribe((/**
         * @param {?} newValue
         * @return {?}
         */
        (newValue) => {
            if (control.value !== newValue) {
                control.setValue(newValue, { emitEvent: false });
            }
        }));
        this.formProperty.errorsChanges.subscribe((/**
         * @param {?} errors
         * @return {?}
         */
        (errors) => {
            control.setErrors(errors, { emitEvent: true });
            /** @type {?} */
            const messages = (errors || [])
                .filter((/**
             * @param {?} e
             * @return {?}
             */
            e => {
                return e.path && e.path.slice(1) === this.formProperty.path;
            }))
                .map((/**
             * @param {?} e
             * @return {?}
             */
            e => e.message));
            this.errorMessages = messages.filter((/**
             * @param {?} m
             * @param {?} i
             * @return {?}
             */
            (m, i) => messages.indexOf(m) === i));
        }));
        control.valueChanges.subscribe((/**
         * @param {?} newValue
         * @return {?}
         */
        (newValue) => {
            this.formProperty.setValue(newValue, false);
        }));
    }
}
class ArrayLayoutWidget extends Widget {
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        /** @type {?} */
        const control = this.control;
        this.formProperty.errorsChanges.subscribe((/**
         * @param {?} errors
         * @return {?}
         */
        (errors) => {
            control.setErrors(errors, { emitEvent: true });
        }));
    }
}
class ObjectLayoutWidget extends Widget {
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        /** @type {?} */
        const control = this.control;
        this.formProperty.errorsChanges.subscribe((/**
         * @param {?} errors
         * @return {?}
         */
        (errors) => {
            control.setErrors(errors, { emitEvent: true });
        }));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ArrayWidget extends ArrayLayoutWidget {
    /**
     * @return {?}
     */
    addItem() {
        this.formProperty.addItem();
        this.updateButtonDisabledState();
    }
    /**
     * @param {?} item
     * @return {?}
     */
    removeItem(item) {
        this.formProperty.removeItem(item);
        this.updateButtonDisabledState();
    }
    /**
     * @param {?} index
     * @param {?} item
     * @return {?}
     */
    trackByIndex(index, item) {
        return index;
    }
    /**
     * @return {?}
     */
    updateButtonDisabledState() {
        this.buttonDisabledAdd = this.isAddButtonDisabled();
        this.buttonDisabledRemove = this.isRemoveButtonDisabled();
    }
    /**
     * @return {?}
     */
    isAddButtonDisabled() {
        if (this.schema.hasOwnProperty('maxItems') && Array.isArray(this.formProperty.properties)) {
            if (this.formProperty.properties.length >= this.schema.maxItems) {
                return true;
            }
        }
        return false;
    }
    /**
     * @return {?}
     */
    isRemoveButtonDisabled() {
        if (this.schema.hasOwnProperty('minItems') && Array.isArray(this.formProperty.properties)) {
            if (this.formProperty.properties.length <= this.schema.minItems) {
                return true;
            }
        }
        return false;
    }
}
ArrayWidget.decorators = [
    { type: Component, args: [{
                selector: 'sf-array-widget',
                template: `<div class="widget form-group">
	<label [attr.for]="id" class="horizontal control-label">
		{{ schema.title }}
	</label>
	<span *ngIf="schema.description" class="formHelp">{{schema.description}}</span>
	<div *ngFor="let itemProperty of formProperty.properties">
		<sf-form-element [formProperty]="itemProperty"></sf-form-element>
		<button (click)="removeItem(itemProperty)" class="btn btn-default array-remove-button"
			[disabled]="isRemoveButtonDisabled()" 
			*ngIf="!(schema.hasOwnProperty('minItems') && schema.hasOwnProperty('maxItems') && schema.minItems === schema.maxItems)"
			>
			<span class="glyphicon glyphicon-minus" aria-hidden="true"></span> Remove
		</button>
	</div>
	<button (click)="addItem()" class="btn btn-default array-add-button"
		[disabled]="isAddButtonDisabled()"
		*ngIf="!(schema.hasOwnProperty('minItems') && schema.hasOwnProperty('maxItems') && schema.minItems === schema.maxItems)"
	>
		<span class="glyphicon glyphicon-plus" aria-hidden="true"></span> Add
	</button>
</div>`
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ButtonWidget {
}
ButtonWidget.decorators = [
    { type: Component, args: [{
                selector: 'sf-button-widget',
                template: '<button (click)="button.action($event)">{{button.label}}</button>'
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ObjectWidget extends ObjectLayoutWidget {
}
ObjectWidget.decorators = [
    { type: Component, args: [{
                selector: 'sf-form-object',
                template: `<fieldset *ngFor="let fieldset of formProperty.schema.fieldsets">
	<legend *ngIf="fieldset.title">{{fieldset.title}}</legend>
	<div *ngIf="fieldset.description">{{fieldset.description}}</div>
	<div *ngFor="let fieldId of fieldset.fields">
		<sf-form-element [formProperty]="formProperty.getProperty(fieldId)"></sf-form-element>
	</div>
</fieldset>`
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CheckboxWidget extends ControlWidget {
    constructor() {
        super(...arguments);
        this.checked = {};
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        /** @type {?} */
        const control = this.control;
        this.formProperty.valueChanges.subscribe((/**
         * @param {?} newValue
         * @return {?}
         */
        (newValue) => {
            if (control.value !== newValue) {
                control.setValue(newValue, { emitEvent: false });
                if (newValue && Array.isArray(newValue)) {
                    newValue.map((/**
                     * @param {?} v
                     * @return {?}
                     */
                    v => this.checked[v] = true));
                }
            }
        }));
        this.formProperty.errorsChanges.subscribe((/**
         * @param {?} errors
         * @return {?}
         */
        (errors) => {
            control.setErrors(errors, { emitEvent: true });
        }));
        control.valueChanges.subscribe((/**
         * @param {?} newValue
         * @return {?}
         */
        (newValue) => {
            this.formProperty.setValue(newValue, false);
        }));
    }
    /**
     * @param {?} el
     * @return {?}
     */
    onCheck(el) {
        if (el.checked) {
            this.checked[el.value] = true;
        }
        else {
            delete this.checked[el.value];
        }
        this.formProperty.setValue(Object.keys(this.checked), false);
    }
}
CheckboxWidget.decorators = [
    { type: Component, args: [{
                selector: 'sf-checkbox-widget',
                template: `<div class="widget form-group">
    <label [attr.for]="id" class="horizontal control-label">
        {{ schema.title }}
    </label>
	<div *ngIf="schema.type!='array'" class="checkbox">
		<label class="horizontal control-label">
			<input [formControl]="control" [attr.name]="name" [attr.id]="id" [indeterminate]="control.value !== false && control.value !== true ? true :null" type="checkbox" [disabled]="schema.readOnly">
			<input *ngIf="schema.readOnly" [attr.name]="name" type="hidden" [formControl]="control">
			{{schema.description}}
		</label>
	</div>
	<ng-container *ngIf="schema.type==='array'">
		<div *ngFor="let option of schema.items.oneOf" class="checkbox">
			<label class="horizontal control-label">
				<input [attr.name]="name"
					value="{{option.enum[0]}}" type="checkbox" 
					[attr.disabled]="schema.readOnly"
					(change)="onCheck($event.target)"
					[attr.checked]="checked[option.enum[0]] ? true : null"
					[attr.id]="id + '.' + option.enum[0]"
					>
				{{option.description}}
			</label>
		</div>
	</ng-container>
</div>`
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FileWidget extends ControlWidget {
    constructor() {
        super();
        this.reader = new FileReader();
        this.filedata = {};
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // OVERRIDE ControlWidget ngAfterViewInit() as ReactiveForms do not handle
        // file inputs
        /** @type {?} */
        const control = this.control;
        this.formProperty.errorsChanges.subscribe((/**
         * @param {?} errors
         * @return {?}
         */
        (errors) => {
            control.setErrors(errors, { emitEvent: true });
        }));
        this.reader.onloadend = (/**
         * @return {?}
         */
        () => {
            this.filedata.data = window.btoa(((/** @type {?} */ (this.reader.result))));
            this.formProperty.setValue(this.filedata, false);
        });
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onFileChange($event) {
        /** @type {?} */
        const file = $event.target.files[0];
        this.filedata.filename = file.name;
        this.filedata.size = file.size;
        this.filedata['content-type'] = file.type;
        this.filedata.encoding = 'base64';
        this.reader.readAsBinaryString(file);
    }
}
FileWidget.decorators = [
    { type: Component, args: [{
                selector: 'sf-file-widget',
                template: `<div class="widget form-group">
	<label [attr.for]="id" class="horizontal control-label">
		{{ schema.title }}
	</label>
    <span *ngIf="schema.description" class="formHelp">{{schema.description}}</span>
  <input [name]="name" class="text-widget file-widget" [attr.id]="id"
    [formControl]="control" type="file" [attr.disabled]="schema.readOnly?true:null"
    (change)="onFileChange($event)">
	<input *ngIf="schema.readOnly" [attr.name]="name" type="hidden" [formControl]="control">
</div>`
            }] }
];
/** @nocollapse */
FileWidget.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IntegerWidget extends ControlWidget {
}
IntegerWidget.decorators = [
    { type: Component, args: [{
                selector: 'sf-integer-widget',
                template: `<div class="widget form-group">
	<label [attr.for]="id" class="horizontal control-label">
		{{ schema.title }}
	</label>
  <span *ngIf="schema.description" class="formHelp">{{schema.description}}</span>
	<input [attr.readonly]="schema.readOnly?true:null" [attr.name]="name"
	[attr.id]="id"
	class="text-widget integer-widget form-control" [formControl]="control"
	[attr.type]="'number'" [attr.min]="schema.minimum" [attr.max]="schema.maximum"
	[attr.placeholder]="schema.placeholder"
	[attr.maxLength]="schema.maxLength || null"
  [attr.minLength]="schema.minLength || null">
</div>`
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TextAreaWidget extends ControlWidget {
}
TextAreaWidget.decorators = [
    { type: Component, args: [{
                selector: 'sf-textarea-widget',
                template: `<div class="widget form-group">
	<label [attr.for]="id" class="horizontal control-label">
		{{ schema.title }}
	</label>
    <span *ngIf="schema.description" class="formHelp">{{schema.description}}</span>
	<textarea [readonly]="schema.readOnly" [name]="name"
		[attr.id]="id"
		class="text-widget textarea-widget form-control"
		[attr.placeholder]="schema.placeholder"
		[attr.maxLength]="schema.maxLength || null"
    [attr.minLength]="schema.minLength || null"
		[formControl]="control"></textarea>
</div>`
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RadioWidget extends ControlWidget {
}
RadioWidget.decorators = [
    { type: Component, args: [{
                selector: 'sf-radio-widget',
                template: `<div class="widget form-group">
	<label>{{schema.title}}</label>
    <span *ngIf="schema.description" class="formHelp">{{schema.description}}</span>
	<div *ngFor="let option of schema.oneOf" class="radio">
		<label class="horizontal control-label">
			<input [formControl]="control" [attr.name]="name" [attr.id]="id + '.' + option.enum[0]" value="{{option.enum[0]}}" type="radio"  [disabled]="schema.readOnly||option.readOnly">
			{{option.description}}
		</label>
	</div>
	<input *ngIf="schema.readOnly" [attr.name]="name" type="hidden" [formControl]="control">
</div>`
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RangeWidget extends ControlWidget {
}
RangeWidget.decorators = [
    { type: Component, args: [{
                selector: 'sf-range-widget',
                template: `<div class="widget form-group">
	<label [attr.for]="id" class="horizontal control-label">
		{{ schema.title }}
	</label>
    <span *ngIf="schema.description" class="formHelp">{{schema.description}}</span>	
	<input [name]="name" class="text-widget range-widget" [attr.id]="id"
	[formControl]="control" [attr.type]="'range'" [attr.min]="schema.minimum" [attr.max]="schema.maximum" [disabled]="schema.readOnly?true:null" >
	<input *ngIf="schema.readOnly" [attr.name]="name" type="hidden">
</div>`
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SelectWidget extends ControlWidget {
}
SelectWidget.decorators = [
    { type: Component, args: [{
                selector: 'sf-select-widget',
                template: `<div class="widget form-group">
	<label [attr.for]="id" class="horizontal control-label">
		{{ schema.title }}
	</label>

	<span *ngIf="schema.description" class="formHelp">
		{{schema.description}}
	</span>

	<select *ngIf="schema.type!='array'" [formControl]="control" [attr.name]="name" [attr.id]="id" [disabled]="schema.readOnly" [disableControl]="schema.readOnly" class="form-control">
		<ng-container *ngIf="schema.oneOf; else use_enum">
			<option *ngFor="let option of schema.oneOf" [ngValue]="option.enum[0]" >{{option.description}}</option>
		</ng-container>
		<ng-template #use_enum>
			<option *ngFor="let option of schema.enum" [ngValue]="option" >{{option}}</option>
		</ng-template>
	</select>

	<select *ngIf="schema.type==='array'" multiple [formControl]="control" [attr.name]="name" [attr.id]="id" [disabled]="schema.readOnly" [disableControl]="schema.readOnly" class="form-control">
    <option *ngFor="let option of schema.items.oneOf" [ngValue]="option.enum[0]" [disabled]="option.readOnly">{{option.description}}</option>
	</select>

	<input *ngIf="schema.readOnly" [attr.name]="name" type="hidden" [formControl]="control">
</div>`
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StringWidget extends ControlWidget {
    /**
     * @return {?}
     */
    getInputType() {
        if (!this.schema.widget.id || this.schema.widget.id === 'string') {
            return 'text';
        }
        else {
            return this.schema.widget.id;
        }
    }
}
StringWidget.decorators = [
    { type: Component, args: [{
                selector: 'sf-string-widget',
                template: `<input *ngIf="this.schema.widget.id ==='hidden'; else notHiddenFieldBlock"
  [attr.name]="name" type="hidden" [formControl]="control">
<ng-template #notHiddenFieldBlock>
<div class="widget form-group">
    <label [attr.for]="id" class="horizontal control-label">
    	{{ schema.title }}
    </label>
    <span *ngIf="schema.description" class="formHelp">{{schema.description}}</span>
    <input [name]="name" [attr.readonly]="(schema.widget.id!=='color') && schema.readOnly?true:null"
    class="text-widget.id textline-widget form-control"
    [attr.type]="!this.schema.widget.id || this.schema.widget.id === 'string' ? 'text' : this.schema.widget.id"
    [attr.id]="id"  [formControl]="control" [attr.placeholder]="schema.placeholder"
    [attr.maxLength]="schema.maxLength || null"
    [attr.minLength]="schema.minLength || null"
    [attr.required]="schema.isRequired || null"
    [attr.disabled]="(schema.widget.id=='color' && schema.readOnly)?true:null">
    <input *ngIf="(schema.widget.id==='color' && schema.readOnly)" [attr.name]="name" type="hidden" [formControl]="control">
</div>
</ng-template>`
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DefaultWidgetRegistry extends WidgetRegistry {
    constructor() {
        super();
        this.register('array', ArrayWidget);
        this.register('object', ObjectWidget);
        this.register('string', StringWidget);
        this.register('search', StringWidget);
        this.register('tel', StringWidget);
        this.register('url', StringWidget);
        this.register('email', StringWidget);
        this.register('password', StringWidget);
        this.register('color', StringWidget);
        this.register('date', StringWidget);
        this.register('date-time', StringWidget);
        this.register('time', StringWidget);
        this.register('integer', IntegerWidget);
        this.register('number', IntegerWidget);
        this.register('range', RangeWidget);
        this.register('textarea', TextAreaWidget);
        this.register('file', FileWidget);
        this.register('select', SelectWidget);
        this.register('radio', RadioWidget);
        this.register('boolean', CheckboxWidget);
        this.register('checkbox', CheckboxWidget);
        this.register('button', ButtonWidget);
        this.setDefaultWidget(StringWidget);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DisableControlDirective {
    /**
     * @param {?} ngControl
     */
    constructor(ngControl) {
        this.ngControl = ngControl;
    }
    /**
     * @param {?} condition
     * @return {?}
     */
    set disableControl(condition) {
        /** @type {?} */
        const action = condition ? 'disable' : 'enable';
        this.ngControl.control[action]();
    }
}
DisableControlDirective.decorators = [
    { type: Directive, args: [{
                selector: '[disableControl]'
            },] }
];
/** @nocollapse */
DisableControlDirective.ctorParameters = () => [
    { type: NgControl }
];
DisableControlDirective.propDecorators = {
    disableControl: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DefaultWidget {
}
DefaultWidget.decorators = [
    { type: Component, args: [{
                selector: 'sf-default-field',
                template: `<p>Unknow type</p>`
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const moduleProviders = [
    {
        provide: WidgetRegistry,
        useClass: DefaultWidgetRegistry
    },
    {
        provide: SchemaValidatorFactory,
        useClass: ZSchemaValidatorFactory
    },
    {
        provide: ExpressionCompilerFactory,
        useClass: JEXLExpressionCompilerFactory
    }
];
class SchemaFormModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: SchemaFormModule,
            providers: [...moduleProviders]
        };
    }
}
SchemaFormModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule, ReactiveFormsModule],
                declarations: [
                    FormElementComponent,
                    FormElementComponentAction,
                    FormComponent,
                    WidgetChooserComponent,
                    DefaultWidget,
                    ArrayWidget,
                    ButtonWidget,
                    ObjectWidget,
                    CheckboxWidget,
                    FileWidget,
                    IntegerWidget,
                    TextAreaWidget,
                    RadioWidget,
                    RangeWidget,
                    SelectWidget,
                    StringWidget,
                    DisableControlDirective
                ],
                entryComponents: [
                    FormElementComponent,
                    FormElementComponentAction,
                    FormComponent,
                    WidgetChooserComponent,
                    ArrayWidget,
                    ButtonWidget,
                    ObjectWidget,
                    CheckboxWidget,
                    FileWidget,
                    IntegerWidget,
                    TextAreaWidget,
                    RadioWidget,
                    RangeWidget,
                    SelectWidget,
                    StringWidget
                ],
                exports: [
                    FormComponent,
                    FormElementComponent,
                    FormElementComponentAction,
                    WidgetChooserComponent,
                    ArrayWidget,
                    ButtonWidget,
                    ObjectWidget,
                    CheckboxWidget,
                    FileWidget,
                    IntegerWidget,
                    TextAreaWidget,
                    RadioWidget,
                    RangeWidget,
                    SelectWidget,
                    StringWidget,
                    DisableControlDirective
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TemplateSchemaService {
    constructor() {
        this.changes = new EventEmitter();
    }
    /**
     * @return {?}
     */
    changed() {
        this.changes.emit();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TemplateSchemaElement {
    /**
     * @param {?} elementRef
     * @return {?}
     */
    getTextContent(elementRef) {
        /** @type {?} */
        const nodes = Array.from(elementRef.nativeElement.childNodes);
        /** @type {?} */
        const node = (/** @type {?} */ (nodes.filter((/**
         * @param {?} el
         * @return {?}
         */
        (el) => {
            return el.nodeType === el.TEXT_NODE;
        })).pop()));
        if (!node || !node.nodeValue) {
            return '';
        }
        return node.nodeValue.trim();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ButtonComponent extends TemplateSchemaElement {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        super();
        this.elementRef = elementRef;
        this.label = '';
        this.click = new EventEmitter();
    }
    /**
     * @private
     * @return {?}
     */
    setLabelFromContent() {
        /** @type {?} */
        const textContent = this.getTextContent(this.elementRef);
        // label as @Input takes priority over content text
        if (textContent && !this.label) {
            this.label = textContent;
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.setLabelFromContent();
    }
}
ButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'sf-button',
                template: "<ng-content></ng-content>\n",
                providers: [
                    {
                        provide: TemplateSchemaElement,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ButtonComponent)),
                    }
                ]
            }] }
];
/** @nocollapse */
ButtonComponent.ctorParameters = () => [
    { type: ElementRef }
];
ButtonComponent.propDecorators = {
    id: [{ type: Input }],
    label: [{ type: Input }],
    widget: [{ type: Input }],
    click: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const FieldType = {
    String: 'string',
    Object: 'object',
    Array: 'array',
    Boolean: 'boolean',
    Integer: 'integer',
    Number: 'number',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class FieldParent extends TemplateSchemaElement {
    constructor() {
        super(...arguments);
        this.name = '';
    }
    /**
     * @return {?}
     */
    get path() {
        if (!this.name) {
            return '';
        }
        return '/' + this.name;
    }
    /**
     * @return {?}
     */
    getButtons() {
        return this.childButtons.map((/**
         * @param {?} button
         * @param {?} index
         * @return {?}
         */
        (button, index) => {
            if (!button.id) {
                /** @type {?} */
                const randomString = Math.random().toString(16).substr(2, 8);
                // generate id for button
                button.id = this.name + randomString + '_' + (index + 1);
            }
            // register as button action the EventEmitter click
            this.actionRegistry.register(button.id, button.click.emit.bind(button.click));
            /** @type {?} */
            const _button = (/** @type {?} */ ({
                id: button.id,
                label: button.label,
            }));
            if (button.widget) {
                _button.widget = button.widget;
            }
            return _button;
        }));
    }
    /**
     * @protected
     * @param {?} fields
     * @return {?}
     */
    getFieldsValidators(fields) {
        return fields.reduce((/**
         * @param {?} validators
         * @param {?} field
         * @return {?}
         */
        (validators, field) => {
            return validators.concat(field.getValidators());
        }), []);
    }
    /**
     * @protected
     * @param {?} fields
     * @return {?}
     */
    getFieldsSchema(fields) {
        return fields.reduce((/**
         * @param {?} schema
         * @param {?} field
         * @return {?}
         */
        (schema, field) => {
            switch (this.type) {
                case FieldType.Array:
                    schema.items = field.getSchema();
                    break;
                default:
                    if (!schema.properties) {
                        schema.properties = {};
                    }
                    schema.properties[field.name] = field.getSchema();
                    break;
            }
            /** @type {?} */
            const buttons = field.getButtons();
            if (buttons.length > 0) {
                schema.buttons = buttons;
            }
            if (!field.required) {
                return schema;
            }
            if (!schema.required) {
                schema.required = [];
            }
            schema.required.push(field.name);
            return schema;
        }), {});
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ItemComponent extends TemplateSchemaElement {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        super();
        this.elementRef = elementRef;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.description = this.getTextContent(this.elementRef);
    }
}
ItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'sf-item',
                template: "<ng-content></ng-content>\n"
            }] }
];
/** @nocollapse */
ItemComponent.ctorParameters = () => [
    { type: ElementRef }
];
ItemComponent.propDecorators = {
    value: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FieldComponent extends FieldParent {
    /**
     * @param {?} elementRef
     * @param {?} templateSchemaService
     * @param {?} actionRegistry
     */
    constructor(elementRef, templateSchemaService, actionRegistry) {
        super();
        this.elementRef = elementRef;
        this.templateSchemaService = templateSchemaService;
        this.actionRegistry = actionRegistry;
        this.type = FieldType.String;
        this.schema = {};
    }
    /**
     * @return {?}
     */
    getSchema() {
        const { properties, items, required } = this.getFieldsSchema(this.childFields.filter((/**
         * @param {?} field
         * @return {?}
         */
        field => field !== this)));
        /** @type {?} */
        const oneOf = this.getOneOf();
        /** @type {?} */
        const schema = (/** @type {?} */ ({
            type: this.type
        }));
        if (this.title !== undefined) {
            schema.title = this.title;
        }
        if (properties !== undefined) {
            schema.properties = properties;
        }
        if (items !== undefined) {
            schema.items = items;
        }
        // requried child fields
        if (required !== undefined) {
            schema.required = required;
        }
        if (oneOf !== undefined) {
            schema.oneOf = oneOf;
        }
        if (this.description !== undefined) {
            schema.description = this.description;
        }
        if (this.placeholder !== undefined) {
            schema.placeholder = this.placeholder;
        }
        if (this.format !== undefined) {
            schema.format = this.format;
        }
        if (this.widget !== undefined) {
            schema.widget = this.widget;
        }
        if (this.readOnly !== undefined) {
            schema.readOnly = this.readOnly;
        }
        /** @type {?} */
        const buttons = this.getButtons();
        if (buttons.length > 0) {
            schema.buttons = buttons;
        }
        // @Input schema takes precedence
        return Object.assign(schema, this.schema);
    }
    /**
     * @return {?}
     */
    getValidators() {
        // registering validator here is not possible since prop full path is needed
        /** @type {?} */
        const childValidators = this.getFieldsValidators(this.childFields.filter((/**
         * @param {?} field
         * @return {?}
         */
        field => field !== this)));
        /** @type {?} */
        const validators = childValidators.map((/**
         * @param {?} __0
         * @return {?}
         */
        ({ path, validator }) => {
            return {
                path: this.path + path,
                validator
            };
        }));
        if (!this.validator) {
            return validators;
        }
        validators.push({ path: this.path, validator: this.validator });
        return validators;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const keys = Object.keys(changes);
        if (keys.length > 0) {
            for (const key of keys) {
                if (!changes[key].isFirstChange()) {
                    // on any input change, force schema change generation
                    this.templateSchemaService.changed();
                    break;
                }
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    getOneOf() {
        if (this.childItems.length === 0) {
            return;
        }
        /** @type {?} */
        const items = this.childItems.map((/**
         * @param {?} __0
         * @return {?}
         */
        ({ value, description }) => {
            if (!Array.isArray(value)) {
                return { enum: [value], description };
            }
            return { enum: value, description };
        }));
        if (items.length === 0) {
            return;
        }
        return items;
    }
    /**
     * @private
     * @return {?}
     */
    setTitleFromContent() {
        /** @type {?} */
        const textContent = this.getTextContent(this.elementRef);
        //  title as @Input takes priority over content text
        if (textContent && !this.title) {
            this.title = textContent;
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        // cache it
        this.setTitleFromContent();
        merge(this.childFields.changes, this.childItems.changes, this.childButtons.changes)
            .subscribe((/**
         * @return {?}
         */
        () => this.templateSchemaService.changed()));
    }
}
FieldComponent.decorators = [
    { type: Component, args: [{
                selector: 'sf-field',
                template: "<ng-content ></ng-content>\n"
            }] }
];
/** @nocollapse */
FieldComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: TemplateSchemaService },
    { type: ActionRegistry }
];
FieldComponent.propDecorators = {
    childFields: [{ type: ContentChildren, args: [FieldComponent,] }],
    childItems: [{ type: ContentChildren, args: [ItemComponent,] }],
    childButtons: [{ type: ContentChildren, args: [ButtonComponent,] }],
    name: [{ type: Input }],
    type: [{ type: Input }],
    format: [{ type: Input }],
    required: [{ type: Input }],
    readOnly: [{ type: Input }],
    title: [{ type: Input }],
    description: [{ type: Input }],
    placeholder: [{ type: Input }],
    widget: [{ type: Input }],
    validator: [{ type: Input }],
    schema: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TemplateSchemaDirective extends FieldParent {
    /**
     * @param {?} actionRegistry
     * @param {?} validatorRegistry
     * @param {?} formComponent
     * @param {?} terminatorService
     * @param {?} templateSchemaService
     */
    constructor(actionRegistry, validatorRegistry, formComponent, terminatorService, templateSchemaService) {
        super();
        this.actionRegistry = actionRegistry;
        this.validatorRegistry = validatorRegistry;
        this.formComponent = formComponent;
        this.terminatorService = terminatorService;
        this.templateSchemaService = templateSchemaService;
    }
    /**
     * @param {?} fields
     * @return {?}
     */
    setFormDocumentSchema(fields) {
        this.actionRegistry.clear();
        this.validatorRegistry.clear();
        /** @type {?} */
        const schema = this.getFieldsSchema(fields);
        /** @type {?} */
        const validators = this.getFieldsValidators(fields);
        validators.forEach((/**
         * @param {?} __0
         * @return {?}
         */
        ({ path, validator }) => {
            this.validatorRegistry.register(path, validator);
        }));
        /** @type {?} */
        const previousSchema = this.formComponent.schema;
        this.formComponent.schema = {
            type: FieldType.Object,
            properties: schema.properties
        };
        if (schema.required && schema.required.length > 0) {
            this.formComponent.schema.requred = schema.required;
        }
        /** @type {?} */
        const buttons = this.getButtons();
        if (buttons.length > 0) {
            this.formComponent.schema.buttons = buttons;
        }
        this.formComponent.ngOnChanges({
            schema: new SimpleChange(previousSchema, this.formComponent.schema, Boolean(previousSchema))
        });
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.childFields.length > 0) {
            this.setFormDocumentSchema(this.childFields.toArray());
        }
        merge(this.childFields.changes, this.templateSchemaService.changes)
            .subscribe((/**
         * @return {?}
         */
        () => {
            this.terminatorService.destroy();
            this.setFormDocumentSchema(this.childFields.toArray());
        }));
    }
}
TemplateSchemaDirective.decorators = [
    { type: Directive, args: [{
                selector: 'sf-form[templateSchema]',
                providers: [
                    TemplateSchemaService
                ]
            },] }
];
/** @nocollapse */
TemplateSchemaDirective.ctorParameters = () => [
    { type: ActionRegistry },
    { type: ValidatorRegistry },
    { type: FormComponent },
    { type: TerminatorService },
    { type: TemplateSchemaService }
];
TemplateSchemaDirective.propDecorators = {
    childFields: [{ type: ContentChildren, args: [FieldComponent,] }],
    childButtons: [{ type: ContentChildren, args: [ButtonComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TemplateSchemaModule {
}
TemplateSchemaModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    TemplateSchemaDirective,
                    FieldComponent,
                    ButtonComponent,
                    ItemComponent
                ],
                exports: [
                    TemplateSchemaDirective,
                    FieldComponent,
                    ButtonComponent,
                    ItemComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { FormComponent, FormElementComponent, FormElementComponentAction, WidgetChooserComponent, WidgetRegistry, FormProperty, ArrayProperty, FormPropertyFactory, SchemaPreprocessor, ValidatorRegistry, ActionRegistry, BindingRegistry, SchemaValidatorFactory, ZSchemaValidatorFactory, WidgetFactory, TerminatorService, Widget, ControlWidget, ArrayLayoutWidget, ObjectLayoutWidget, ArrayWidget, ButtonWidget, ObjectWidget, CheckboxWidget, FileWidget, IntegerWidget, TextAreaWidget, RadioWidget, RangeWidget, SelectWidget, StringWidget, DefaultWidgetRegistry, DisableControlDirective, SchemaFormModule, TemplateSchemaModule, DefaultWidget as ɵj, ExpressionCompilerFactory as ɵh, JEXLExpressionCompilerFactory as ɵi, useFactory as ɵa, ActionRegistry as ɵb, BindingRegistry as ɵe, FormPropertyFactory as ɵg, SchemaPreprocessor as ɵf, ValidatorRegistry as ɵc, PropertyBindingRegistry as ɵd, ButtonComponent as ɵq, FieldParent as ɵl, FieldComponent as ɵo, ItemComponent as ɵp, TemplateSchemaElement as ɵm, TemplateSchemaDirective as ɵk, TemplateSchemaService as ɵn };

//# sourceMappingURL=ngx-schema-form.js.map